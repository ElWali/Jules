<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="referrer" content="origin">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Atlas.js - Professional JavaScript Mapping Library (COMPLETE)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    #map-container {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
      cursor: grab;
      -webkit-tap-highlight-color: transparent;
    }
    #map-container.dragging,
    #map-container .atlas-marker.dragging {
      cursor: grabbing;
      cursor: -webkit-grabbing;
    }
    #map-container.drawing {
      cursor: crosshair;
    }
    #map {
      width: 100%;
      height: 100%;
      display: block;
    }
    .atlas-control-container {
      position: absolute;
      z-index: 1000;
      pointer-events: none;
    }
    .atlas-control-container > * {
      pointer-events: auto;
    }
    .atlas-control-top-left { top: 10px; left: 10px; }
    .atlas-control-top-right { top: 10px; right: 10px; }
    .atlas-control-bottom-left { bottom: 10px; left: 10px; }
    .atlas-control-bottom-right { bottom: 10px; right: 10px; }
    .atlas-control-vertical {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .atlas-control-horizontal {
      display: flex;
      flex-direction: row;
      gap: 5px;
    }
    .control-btn {
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      font-size: 16px;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 4px;
      user-select: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      transition: all 0.15s ease;
      min-width: 30px;
      text-align: center;
    }
    .control-btn:hover {
      background: rgba(240, 240, 240, 0.95);
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
    }
    .control-btn:active {
      background: rgba(224, 224, 224, 0.95);
      transform: scale(0.98);
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
    }
    .control-btn:focus {
      outline: 2px solid #0078A8;
      outline-offset: 2px;
    }
    .control-btn:disabled {
      background: rgba(245, 245, 245, 0.9);
      color: #aaa;
      cursor: not-allowed;
      transform: none;
      border-color: #ddd;
      box-shadow: none;
    }
    .control-btn.active {
      background: rgba(0, 120, 168, 0.9);
      color: white;
      border-color: #0078A8;
    }
    #loading {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      display: none;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    #loading.visible {
      display: block;
    }
    #coords {
      position: absolute;
      bottom: 25px;
      left: 5px;
      background: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }
    #zoom-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.9);
      font-size: 20px;
      padding: 6px 12px;
      border-radius: 6px;
      opacity: 0;
      transition: opacity 0.25s ease-in-out;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      font-weight: bold;
      z-index: 1000;
    }
    .scale-bar-container {
      text-align: center;
      font-size: 11px;
      color: #fff;
      cursor: pointer;
      background: rgba(0,0,0,0.5);
      padding: 2px 4px;
      border-radius: 3px;
    }
    .scale-bar {
      height: 4px;
      background: #fff;
      margin-bottom: 2px;
      border-radius: 2px;
    }
    #attribution {
      position: absolute;
      bottom: 5px;
      left: 10px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      font-size: 11px;
      padding: 3px 6px;
      border-radius: 3px;
      font-family: sans-serif;
      max-width: 50%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    #attribution a {
      text-decoration: none;
      color: #4d90fe;
      font-weight: bold;
    }
    #attribution a:hover {
      text-decoration: underline;
    }
    @keyframes zoom-indicator {
      0% {
        transform: scale(0.2);
        opacity: 0.8;
      }
      100% {
        transform: scale(1.2);
        opacity: 0;
      }
    }

    /* --- PROFESSIONAL OVERLAY STYLES --- */
    .atlas-marker {
      position: absolute;
      width: 24px;
      height: 36px;
      cursor: pointer;
      z-index: 1000;
      transition: transform 0.2s cubic-bezier(0.2, 0.8, 0.4, 1.0), z-index 0s;
      will-change: transform, z-index;
    }

    .atlas-marker-icon {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 24px;
      height: 36px;
      line-height: 36px;
      text-align: center;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
    }

    .atlas-marker-shadow {
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 24px;
      height: 12px;
      transform: translateX(-50%);
      border-radius: 50%;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0) 70%);
      filter: blur(1px);
    }

    .atlas-marker.hover {
      transform: translate(-50%, -100%) scale(1.1) !important;
    }

    .atlas-marker-cluster {
      position: absolute;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(0, 120, 168, 0.8);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 1000;
      transition: transform 0.2s ease;
    }

    .atlas-marker-cluster:hover {
      transform: scale(1.2);
      background: rgba(0, 100, 150, 0.9);
    }

    .atlas-popup {
      position: absolute;
      background: #ffffff;
      border: 1px solid #ddd;
      border-radius: 6px;
      box-shadow: 0 3px 15px rgba(0,0,0,0.2);
      padding: 12px;
      font-size: 14px;
      line-height: 1.4;
      z-index: 1001;
      opacity: 0;
      transition: opacity 0.2s ease-in-out, transform 0.2s ease-out;
      will-change: opacity, transform;
      max-width: 300px;
      min-width: 50px;
      box-sizing: border-box;
    }

    .atlas-popup.open {
      opacity: 1;
      transform: translateZ(0);
    }

    .popup-content {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    .popup-close {
      position: absolute;
      top: 8px;
      right: 8px;
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      padding: 0;
      width: 24px;
      height: 24px;
      line-height: 24px;
      text-align: center;
      color: #666;
      border-radius: 50%;
      transition: background-color 0.15s ease;
    }

    .popup-close:hover {
      background: #f0f0f0;
      color: #333;
    }

    .popup-close:focus {
      outline: 2px solid #0078A8;
      outline-offset: 2px;
    }

    /* Popup Tip / Arrow */
    .popup-tip {
      position: absolute;
      width: 0;
      height: 0;
      border: 8px solid transparent;
    }

    .tip-bottom {
      top: -16px;
      left: 50%;
      margin-left: -8px;
      border-top-color: #ddd;
      border-bottom: none;
    }

    .tip-bottom::after {
      content: '';
      position: absolute;
      top: 1px;
      left: -8px;
      border: 8px solid transparent;
      border-top-color: white;
    }

    .tip-top {
      bottom: -16px;
      left: 50%;
      margin-left: -8px;
      border-bottom-color: #ddd;
      border-top: none;
    }

    .tip-top::after {
      content: '';
      position: absolute;
      bottom: 1px;
      left: -8px;
      border: 8px solid transparent;
      border-bottom-color: white;
    }

    .tip-left {
      top: 50%;
      right: -16px;
      margin-top: -8px;
      border-left-color: #ddd;
      border-right: none;
    }

    .tip-left::after {
      content: '';
      position: absolute;
      top: -8px;
      right: 1px;
      border: 8px solid transparent;
      border-left-color: white;
    }

    .tip-right {
      top: 50%;
      left: -16px;
      margin-top: -8px;
      border-right-color: #ddd;
      border-left: none;
    }

    .tip-right::after {
      content: '';
      position: absolute;
      top: -8px;
      left: 1px;
      border: 8px solid transparent;
      border-right-color: white;
    }

    .atlas-notification-container {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2000;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      pointer-events: none;
    }

    .atlas-notification {
      background-color: rgba(40, 40, 40, 0.85);
      color: white;
      padding: 10px 18px;
      border-radius: 20px;
      font-size: 14px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      animation: atlas-notification-fade-in-out 5s ease-in-out forwards;
      pointer-events: auto;
      max-width: 80vw;
      text-align: center;
    }

    @keyframes atlas-notification-fade-in-out {
      0% {
        opacity: 0;
        transform: translateY(-20px);
      }
      10% {
        opacity: 1;
        transform: translateY(0);
      }
      90% {
        opacity: 1;
        transform: translateY(0);
      }
      100% {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    /* Drawing tools styles */
    .drawing-toolbar {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      background: rgba(255, 255, 255, 0.95);
      padding: 8px;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .drawing-info {
      position: absolute;
      bottom: 80px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      max-width: 200px;
      z-index: 500;
    }

    .legend-control {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 4px;
      padding: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      max-height: 300px;
      overflow-y: auto;
      min-width: 200px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-size: 12px;
      cursor: pointer;
      padding: 4px;
      border-radius: 3px;
      transition: background 0.2s ease;
    }

    .legend-item:hover {
      background: rgba(0, 120, 168, 0.1);
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 2px;
      border: 1px solid #ccc;
    }

    .heatmap-legend {
      display: flex;
      height: 20px;
      border-radius: 3px;
      margin-bottom: 8px;
      background: linear-gradient(90deg, blue, cyan, lime, yellow, red);
    }

    .grid-labels {
      position: absolute;
      font-size: 10px;
      color: rgba(0, 0, 0, 0.5);
      pointer-events: none;
    }

    .measurement-display {
      position: absolute;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      pointer-events: none;
      z-index: 500;
    }

    .performance-stats {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #0f0;
      font-family: monospace;
      font-size: 11px;
      padding: 8px;
      border-radius: 4px;
      z-index: 2001;
      line-height: 1.6;
    }
  </style>
</head>
<body>
  <div id="map-container">
    <canvas id="map"></canvas>
    <div id="loading">Loading: <span id="loading-count">0</span></div>
    <div id="zoom-overlay" aria-live="polite"></div>
    <div id="coords" aria-live="polite"></div>
    <div id="attribution"></div>
    <div class="atlas-notification-container"></div>
  </div>

  <script type="module">
    // ============================================================
    // CONSTANTS & CONFIGURATION
    // ============================================================
    const CONSTANTS = {
      EARTH_RADIUS: 6378137,
      EARTH_CIRCUMFERENCE: 2 * Math.PI * 6378137,
      MAX_LATITUDE: 85.05112878,
      MIN_LATITUDE: -85.05112878,
      TILE_SIZE: 256,
      TILE_BUFFER: 3,
      TILE_TTL: 1000 * 60 * 60 * 24,
      TILE_LOAD_TIMEOUT_MS: 10000,
      SCALE_BAR_TARGET_PX: 120,
      INERTIA_DECEL: 0.0025,
      INERTIA_STOP_SPEED: 0.02,
      VELOCITY_WINDOW_MS: 120,
      DOUBLE_TAP_MAX_DELAY: 300,
      DOUBLE_TAP_MAX_MOVE: 16,
      TWO_FINGER_TAP_MAX_DELAY: 250,
      TWO_FINGER_TAP_MOVE_THRESH: 10,
      ROTATE_MOVE_THRESH_RAD: 0.08,
      WHEEL_ZOOM_STEP: 0.25,
      WHEEL_ZOOM_DURATION: 220,
      TAP_ZOOM_DURATION: 280,
      SNAP_DURATION: 300,
      FLYTO_DURATION: 800,
      RAD2DEG: 180 / Math.PI,
      DEG2RAD: Math.PI / 180,
    };

    const LAYERS = {
      OSM: {
        name: "OpenStreetMap",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://a.tile.openstreetmap.org", "https://b.tile.openstreetmap.org", "https://c.tile.openstreetmap.org"],
        attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
        background: "#e6e6e6",
        supportsRetina: true,
        maxCacheSize: 500
      },
      ESRI: {
        name: "Esri Satellite",
        minZoom: 0,
        maxZoom: 19,
        tileServers: ["https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile"],
        attribution: 'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer" target="_blank" rel="noopener noreferrer">Esri World Imagery</a>',
        background: "#000000",
        supportsRetina: false,
        maxCacheSize: 400
      }
    };

    const CONFIG = {
      defaultLayer: "OSM",
      defaultCenter: { lon: 0, lat: 0 },
      defaultZoom: 3,
      retina: "auto",
      retinaSuffix: "@2x"
    };

    const EASING = {
      easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
      easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
      linear: (t) => t
    };

    // ============================================================
    // UTILITY FUNCTIONS
    // ============================================================

    const normalizeAngle = (rad) => Math.atan2(Math.sin(rad), Math.cos(rad));
    const shortestAngleDiff = (from, to) => normalizeAngle(to - from);
    const wrapDeltaLon = (delta) => ((delta + 180) % 360 + 360) % 360 - 180;
    const rot = (x, y, ang) => {
      const c = Math.cos(ang);
      const s = Math.sin(ang);
      return { x: x * c - y * s, y: x * s + y * c };
    };

    // ============================================================
    // PROJECTION SYSTEM
    // ============================================================

    class Projection {
      project(latlng) {
        throw new Error('project() must be implemented by subclass');
      }

      unproject(point) {
        throw new Error('unproject() must be implemented by subclass');
      }
    }

    class WebMercatorProjection extends Projection {
      project(latlng) {
        const d = CONSTANTS.EARTH_RADIUS;
        const maxLat = CONSTANTS.MAX_LATITUDE;
        const lat = Math.max(Math.min(maxLat, latlng.lat), -maxLat);
        const sin = Math.sin(lat * CONSTANTS.DEG2RAD);

        return {
          x: d * latlng.lon * CONSTANTS.DEG2RAD,
          y: d * Math.log((1 + sin) / (1 - sin)) / 2
        };
      }

      unproject(point) {
        const d = CONSTANTS.EARTH_RADIUS;
        return {
          lon: (point.x / d) * CONSTANTS.RAD2DEG,
          lat: (2 * Math.atan(Math.exp(point.y / d)) - (Math.PI / 2)) * CONSTANTS.RAD2DEG
        };
      }

      latLngToTile(latlng, zoom) {
        const scale = Math.pow(2, zoom);
        const projected = this.project(latlng);
        return {
          x: (projected.x + Math.PI * CONSTANTS.EARTH_RADIUS) / (2 * Math.PI * CONSTANTS.EARTH_RADIUS) * scale,
          y: (Math.PI * CONSTANTS.EARTH_RADIUS - projected.y) / (2 * Math.PI * CONSTANTS.EARTH_RADIUS) * scale
        };
      }

      tileToLatLng(x, y, zoom) {
        const scale = Math.pow(2, zoom);
        const projected = {
          x: x / scale * 2 * Math.PI * CONSTANTS.EARTH_RADIUS - Math.PI * CONSTANTS.EARTH_RADIUS,
          y: Math.PI * CONSTANTS.EARTH_RADIUS - y / scale * 2 * Math.PI * CONSTANTS.EARTH_RADIUS
        };
        return this.unproject(projected);
      }
    }

    // Alternative: WGS84 Equirectangular Projection
    class EquirectangularProjection extends Projection {
      project(latlng) {
        const d = CONSTANTS.EARTH_RADIUS;
        return {
          x: d * latlng.lon * CONSTANTS.DEG2RAD,
          y: d * latlng.lat * CONSTANTS.DEG2RAD
        };
      }

      unproject(point) {
        const d = CONSTANTS.EARTH_RADIUS;
        return {
          lon: (point.x / d) * CONSTANTS.RAD2DEG,
          lat: (point.y / d) * CONSTANTS.RAD2DEG
        };
      }

      latLngToTile(latlng, zoom) {
        const scale = Math.pow(2, zoom);
        const projected = this.project(latlng);
        return {
          x: (projected.x / (2 * Math.PI * CONSTANTS.EARTH_RADIUS) + 0.5) * scale,
          y: (0.5 - projected.y / (2 * Math.PI * CONSTANTS.EARTH_RADIUS)) * scale
        };
      }

      tileToLatLng(x, y, zoom) {
        const scale = Math.pow(2, zoom);
        const projected = {
          x: (x / scale - 0.5) * 2 * Math.PI * CONSTANTS.EARTH_RADIUS,
          y: (0.5 - y / scale) * 2 * Math.PI * CONSTANTS.EARTH_RADIUS
        };
        return this.unproject(projected);
      }
    }

    const DEFAULT_PROJECTION = new WebMercatorProjection();

    // ============================================================
    // GIS UTILITIES
    // ============================================================

    class GISUtils {
      static toRadians(degrees) {
        return degrees * Math.PI / 180;
      }

      static toDegrees(radians) {
        return radians * 180 / Math.PI;
      }

      static wrapLongitude(lon) {
        while (lon > 180) lon -= 360;
        while (lon < -180) lon += 360;
        return lon;
      }

      static clampLatitude(lat) {
        return Math.max(CONSTANTS.MIN_LATITUDE, Math.min(CONSTANTS.MAX_LATITUDE, lat));
      }

      static getResolution(lat, z) {
        return (CONSTANTS.EARTH_CIRCUMFERENCE * Math.cos(this.toRadians(lat))) / 
               (Math.pow(2, z) * CONSTANTS.TILE_SIZE);
      }

      static formatDistance(m) {
        return m < 1000 ? Math.round(m) + " m" : (m / 1000).toFixed(1) + " km";
      }

      static tileToLonLat(x, y, z) {
        return DEFAULT_PROJECTION.tileToLatLng(x, y, z);
      }

      /**
       * Calculate distance between two points in meters using Haversine formula
       */
      static getDistance(latlng1, latlng2) {
        const R = CONSTANTS.EARTH_RADIUS;
        const dLat = (latlng2.lat - latlng1.lat) * CONSTANTS.DEG2RAD;
        const dLon = (latlng2.lon - latlng1.lon) * CONSTANTS.DEG2RAD;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(latlng1.lat * CONSTANTS.DEG2RAD) * Math.cos(latlng2.lat * CONSTANTS.DEG2RAD) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      /**
       * Calculate area of polygon in square meters using Shoelace formula
       */
      static getPolygonArea(coordinates) {
        let area = 0;
        const R = CONSTANTS.EARTH_RADIUS;

        for (let i = 0; i < coordinates.length - 1; i++) {
          const latlng1 = { lat: coordinates[i][0], lon: coordinates[i][1] };
          const latlng2 = { lat: coordinates[i + 1][0], lon: coordinates[i + 1][1] };

          const dLat = (latlng2.lat - latlng1.lat) * CONSTANTS.DEG2RAD;
          const dLon = (latlng2.lon - latlng1.lon) * CONSTANTS.DEG2RAD;

          area += Math.sin(latlng1.lat * CONSTANTS.DEG2RAD) * Math.sin(latlng2.lat * CONSTANTS.DEG2RAD) *
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
          area -= Math.sin(dLat / 2) * Math.sin(dLat / 2);
        }

        area = Math.abs(area * R * R / 2);
        return area;
      }

      /**
       * Point in polygon detection using ray casting
       */
      static isPointInPolygon(point, polygon) {
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const xi = polygon[i].lon;
          const yi = polygon[i].lat;
          const xj = polygon[j].lon;
          const yj = polygon[j].lat;

          const intersect = ((yi > point.lat) !== (yj > point.lat)) &&
                           (point.lon < (xj - xi) * (point.lat - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      /**
       * Get bearing between two points
       */
      static getBearing(latlng1, latlng2) {
        const dLon = (latlng2.lon - latlng1.lon) * CONSTANTS.DEG2RAD;
        const y = Math.sin(dLon) * Math.cos(latlng2.lat * CONSTANTS.DEG2RAD);
        const x = Math.cos(latlng1.lat * CONSTANTS.DEG2RAD) * Math.sin(latlng2.lat * CONSTANTS.DEG2RAD) -
                  Math.sin(latlng1.lat * CONSTANTS.DEG2RAD) * Math.cos(latlng2.lat * CONSTANTS.DEG2RAD) * Math.cos(dLon);
        return Math.atan2(y, x);
      }

      /**
       * Get destination point given bearing and distance
       */
      static getDestinationPoint(latlng, bearing, distance) {
        const R = CONSTANTS.EARTH_RADIUS;
        const lat1 = latlng.lat * CONSTANTS.DEG2RAD;
        const lon1 = latlng.lon * CONSTANTS.DEG2RAD;
        const d = distance / R;

        const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d) +
                              Math.cos(lat1) * Math.sin(d) * Math.cos(bearing));
        const lon2 = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(d) * Math.cos(lat1),
                                       Math.cos(d) - Math.sin(lat1) * Math.sin(lat2));

        return {
          lat: lat2 * CONSTANTS.RAD2DEG,
          lon: lon2 * CONSTANTS.RAD2DEG
        };
      }
    }

    // ============================================================
    // LAYER SYSTEM
    // ============================================================

    class Layer {
      constructor(options = {}) {
        this.options = options;
        this._map = null;
        this._events = {};
      }

      addTo(map) {
        if (this._map) {
          this._map.removeLayer(this);
        }
        this._map = map;
        map.addLayer(this);
        return this;
      }

      remove() {
        if (this._map) {
          this._map.removeLayer(this);
          this._map = null;
        }
        return this;
      }

      on(type, fn) {
        if (!this._events[type]) {
          this._events[type] = [];
        }
        this._events[type].push(fn);
        return this;
      }

      off(type, fn) {
        if (!this._events[type]) return this;
        if (!fn) {
          this._events[type] = [];
        } else {
          this._events[type] = this._events[type].filter(cb => cb !== fn);
        }
        return this;
      }

      fire(type, data = {}) {
        if (!this._events[type]) return;
        data.type = type;
        data.target = this;
        this._events[type].forEach(fn => fn(data));
      }

      onAdd() {}
      onRemove() {}
      render() {}
    }

    /**
     * TileLayer - Renders raster tiles
     */
    class TileLayer extends Layer {
      constructor(urlTemplate, options = {}) {
        super(options);
        this.urlTemplate = urlTemplate;
        this.options = {
          minZoom: options.minZoom || 0,
          maxZoom: options.maxZoom || 18,
          attribution: options.attribution || '',
          background: options.background || '#ffffff',
          supportsRetina: options.supportsRetina || false,
          maxCacheSize: options.maxCacheSize || 500,
          ...options
        };

        this.tileCache = new Map();
        this.loadingTiles = new Set();
        this.loadingControllers = new Map();
        this._retinaAvailable = true;
      }

      _getTileUrl(x, y, z) {
        const scale = Math.pow(2, z);
        const wrappedX = ((x % scale) + scale) % scale;
        const intX = Math.floor(wrappedX);
        const intY = Math.max(0, Math.min(scale - 1, Math.floor(y)));

        let url = this.urlTemplate
          .replace('{z}', z)
          .replace('{x}', intX)
          .replace('{y}', intY);

        if (this.options.supportsRetina && this._shouldRequestRetina()) {
          url += CONFIG.retinaSuffix;
        }

        return url;
      }

      _shouldRequestRetina() {
        const mode = CONFIG.retina;
        const want = (mode === true) || (mode === "auto" && (window.devicePixelRatio || 1) > 1.5);
        return want && this._retinaAvailable;
      }

      async _loadTile(key, url) {
        if (this.tileCache.has(key)) {
          return this.tileCache.get(key);
        }

        const controller = new AbortController();
        const { signal } = controller;
        this.loadingControllers.set(key, controller);

        const img = new Image();
        img.crossOrigin = "anonymous";
        const tile = { img, loaded: false, loadedAt: Date.now(), lastUsed: Date.now(), controller };
        this.tileCache.set(key, tile);
        this.loadingTiles.add(key);

        const start = performance.now();
        let timeoutId;

        const timeoutPromise = new Promise((_, reject) => {
          timeoutId = setTimeout(() => {
            if (this.loadingTiles.has(key)) {
              controller.abort();
              console.warn(`[Atlas] Tile load timeout for: ${url}`);
              this.loadingTiles.delete(key);
              this.loadingControllers.delete(key);
              if (this.tileCache.has(key)) {
                this.tileCache.delete(key);
              }
              this.fire('tileerror', { tile: key, url, error: new Error('Timeout') });
              reject(new Error(`Timeout loading tile: ${url}`));
            }
          }, CONSTANTS.TILE_LOAD_TIMEOUT_MS);
        });

        const loadPromise = new Promise((resolve, reject) => {
          img.onload = () => {
            clearTimeout(timeoutId);
            const loadTime = performance.now() - start;
            console.log(`[Atlas] Tile ${key} loaded in ${loadTime.toFixed(2)}ms`);
            tile.loaded = true;
            tile.loadedAt = Date.now();
            this.loadingTiles.delete(key);
            this.loadingControllers.delete(key);

            if (this._map) {
              this._map.scheduleRender();
            }
            this.fire('tileload', { tile: key, url });
            resolve(tile);
          };

          img.onerror = (e) => {
            clearTimeout(timeoutId);
            if (signal.aborted) return;

            console.warn(`[Atlas] Failed to load tile: ${url}`, e);

            if (this.options.supportsRetina && url.includes(CONFIG.retinaSuffix)) {
              this._retinaAvailable = false;
              const nonRetinaUrl = url.replace(CONFIG.retinaSuffix, "");
              img.src = nonRetinaUrl;
              return;
            }

            this.loadingTiles.delete(key);
            this.loadingControllers.delete(key);
            this.fire('tileerror', { tile: key, url, error: e });
            reject(e);
          };

          img.src = url;
        });

        try {
          await Promise.race([loadPromise, timeoutPromise]);
        } catch (error) {
          if (!signal.aborted) {
            console.error("[Atlas] Tile loading failed or timed out:", error.message);
          }
        }

        return tile;
      }

      _reloadTile(key, url) {
        const existing = this.tileCache.get(key);
        if (!existing) return;

        const token = key + "#r";
        if (this.loadingTiles.has(token)) return;

        const doReload = () => {
          const controller = new AbortController();
          const img = new Image();
          img.crossOrigin = "anonymous";
          this.loadingTiles.add(token);

          img.onload = () => {
            existing.img = img;
            existing.loaded = true;
            existing.loadedAt = Date.now();
            this.loadingTiles.delete(token);

            if (this._map) {
              this._map.scheduleRender();
            }
          };

          img.onerror = () => {
            this.loadingTiles.delete(token);
          };

          img.src = url + (url.includes("?") ? "&" : "?") + "v=" + Date.now();
        };

        if ('requestIdleCallback' in window) {
          requestIdleCallback(doReload, { timeout: 2000 });
        } else {
          setTimeout(doReload, 100);
        }
      }

      _evict() {
        if (this.tileCache.size <= this.options.maxCacheSize) return;

        if ('requestIdleCallback' in window) {
          requestIdleCallback(() => this._performEviction(), { timeout: 2000 });
        } else {
          setTimeout(() => this._performEviction(), 100);
        }
      }

      _performEviction() {
        if (this.tileCache.size <= this.options.maxCacheSize) return;

        const entries = Array.from(this.tileCache.entries());
        entries.sort((a, b) => a[1].lastUsed - b[1].lastUsed);

        const removeCount = this.tileCache.size - this.options.maxCacheSize;
        for (let i = 0; i < removeCount; i++) {
          this.tileCache.delete(entries[i][0]);
        }
      }

      _preloadAdjacentZoomTiles() {
        if (!this._map) return;

        const zInt = Math.floor(this._map.zoom);
        const nextZoom = Math.min(this.options.maxZoom, zInt + 1);
        const prevZoom = Math.max(this.options.minZoom, zInt - 1);

        if (Math.abs(this._map.zoom - zInt) > 0.3) return;

        const wrappedCenterLon = GISUtils.wrapLongitude(this._map.center.lon);
        const ct = this._map.projection.latLngToTile({ lat: this._map.center.lat, lon: wrappedCenterLon }, zInt);
        const ts = CONSTANTS.TILE_SIZE;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const viewportTiles = Math.ceil(Math.max(w, h) / ts) + CONSTANTS.TILE_BUFFER;

        for (const dz of [prevZoom, nextZoom]) {
          if (dz === zInt) continue;

          const scaleDiff = Math.pow(2, Math.abs(dz - zInt));
          const startX = Math.floor(ct.x * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);
          const startY = Math.floor(ct.y * (dz > zInt ? scaleDiff : 1 / scaleDiff) - viewportTiles / 2);

          for (let dx = 0; dx < viewportTiles; dx++) {
            for (let dy = 0; dy < viewportTiles; dy++) {
              const X = startX + dx;
              const Y = startY + dy;
              const key = `${dz}/${X}/${Y}`;

              if (!this.tileCache.has(key) && !this.loadingTiles.has(key)) {
                const url = this._getTileUrl(X, Y, dz);
                this._loadTile(key, url);
              }
            }
          }
        }
      }

      render() {
        if (!this._map) return;

        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const zInt = Math.floor(this._map.zoom);
        const scaleFactor = Math.pow(2, this._map.zoom - zInt);
        const ts = CONSTANTS.TILE_SIZE;

        const wrappedCenterLon = GISUtils.wrapLongitude(this._map.center.lon);
        const ct = this._map.projection.latLngToTile({ lat: this._map.center.lat, lon: wrappedCenterLon }, zInt);

        const absCos = Math.abs(Math.cos(this._map.bearing));
        const absSin = Math.abs(Math.sin(this._map.bearing));
        const needW = w * absCos + h * absSin;
        const needH = w * absSin + h * absCos;

        const cols = Math.ceil(needW / (ts * scaleFactor)) + CONSTANTS.TILE_BUFFER;
        const rows = Math.ceil(needH / (ts * scaleFactor)) + CONSTANTS.TILE_BUFFER;

        const startX = Math.floor(ct.x - cols / 2);
        const startY = Math.floor(ct.y - rows / 2);

        const tiles = [];
        for (let dx = 0; dx < cols; dx++) {
          for (let dy = 0; dy < rows; dy++) {
            const X = startX + dx;
            const Y = startY + dy;
            const dist = Math.hypot(dx - cols / 2, dy - rows / 2);
            tiles.push({ X, Y, dist });
          }
        }

        tiles.sort((a, b) => a.dist - b.dist);

        const { ctx } = this._map;
        ctx.save();
        ctx.translate(w / 2, h / 2);
        ctx.rotate(this._map.bearing);
        ctx.scale(scaleFactor, scaleFactor);
        ctx.imageSmoothingEnabled = false;

        for (const { X, Y } of tiles) {
          const key = `${zInt}/${X}/${Y}`;
          const url = this._getTileUrl(X, Y, zInt);
          const trX = (X - ct.x) * ts;
          const trY = (Y - ct.y) * ts;

          let tile = this.tileCache.get(key);
          if (!tile) {
            this._loadTile(key, url);
          } else if (tile.loaded) {
            ctx.drawImage(tile.img, trX, trY, ts, ts);
            tile.lastUsed = Date.now();

            if (tile.loadedAt && (Date.now() - tile.loadedAt > CONSTANTS.TILE_TTL)) {
              this._reloadTile(key, url);
            }
          }
        }

        ctx.restore();
        this._evict();
        this._preloadAdjacentZoomTiles();
      }

      onAdd() {
        this.fire('add');
      }

      onRemove() {
        for (const controller of this.loadingControllers.values()) {
          controller.abort();
        }
        this.loadingTiles.clear();
        this.loadingControllers.clear();
        this.tileCache.clear();
        this.fire('remove');
      }

      getAttribution() {
        return this.options.attribution;
      }

      getBackground() {
        return this.options.background;
      }

      getMinZoom() {
        return this.options.minZoom;
      }

      getMaxZoom() {
        return this.options.maxZoom;
      }
    }

    /**
     * GeoJSONLayer - Renders GeoJSON features
     */
    class GeoJSONLayer extends Layer {
      constructor(geojson, options = {}) {
        super(options);
        this._geojson = this._normalizeGeoJSON(geojson);
        this._features = [];
        this._featureCache = new Map();
        this._hitCache = new Map();
        this._lastRenderZoom = null;
        this._lastRenderBearing = null;
        this._lastRenderCenter = null;

        this.options.style = options.style || {
          color: '#3388ff',
          weight: 3,
          opacity: 1,
          fillColor: '#3388ff',
          fillOpacity: 0.2
        };

        this.options.interactive = options.interactive !== undefined ? options.interactive : true;
        this.options.onEachFeature = options.onEachFeature || null;

        this._onMouseMove = this._onMouseMove.bind(this);
        this._onMouseOut = this._onMouseOut.bind(this);
        this._onClick = this._onClick.bind(this);
        this._hoveredFeature = null;
      }

      _normalizeGeoJSON(input) {
        if (Array.isArray(input)) {
          return {
            type: 'FeatureCollection',
            features: input.map(f => f.type === 'Feature' ? f : { type: 'Feature', geometry: f, properties: {} })
          };
        } else if (input.type === 'FeatureCollection') {
          return input;
        } else if (input.type === 'Feature') {
          return { type: 'FeatureCollection', features: [input] };
        } else {
          return {
            type: 'FeatureCollection',
            features: [{ type: 'Feature', geometry: input, properties: {} }]
          };
        }
      }

      _latLngToScreenPoint(coord) {
        if (!this._map) return { x: 0, y: 0 };

        const [lon, lat] = coord;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;
        const zInt = Math.floor(this._map.zoom);
        const ts = CONSTANTS.TILE_SIZE * Math.pow(2, this._map.zoom - zInt);
        const ct = this._map.projection.latLngToTile(this._map.center, zInt);
        const pt = this._map.projection.latLngToTile({ lat, lon }, zInt);
        const trX = (pt.x - ct.x) * ts;
        const trY = (pt.y - ct.y) * ts;
        const anchorVec = rot(trX, trY, this._map.bearing);
        const screenX = w / 2 + anchorVec.x;
        const screenY = h / 2 + anchorVec.y;

        return { x: screenX, y: screenY };
      }

      _getFeatureStyle(feature) {
        if (typeof this.options.style === 'function') {
          return this.options.style(feature);
        }
        return this.options.style;
      }

      _processFeature(feature) {
        const cacheKey = JSON.stringify(feature);
        if (this._featureCache.has(cacheKey)) {
          return this._featureCache.get(cacheKey);
        }

        const geometry = feature.geometry;
        const processed = { type: geometry.type, coordinates: null, properties: feature.properties };

        switch (geometry.type) {
          case 'Point':
            processed.coordinates = this._latLngToScreenPoint(geometry.coordinates);
            break;
          case 'MultiPoint':
            processed.coordinates = geometry.coordinates.map(coord => this._latLngToScreenPoint(coord));
            break;
          case 'LineString':
            processed.coordinates = geometry.coordinates.map(coord => this._latLngToScreenPoint(coord));
            break;
          case 'MultiLineString':
            processed.coordinates = geometry.coordinates.map(ring => ring.map(coord => this._latLngToScreenPoint(coord)));
            break;
          case 'Polygon':
            processed.coordinates = geometry.coordinates.map(ring => ring.map(coord => this._latLngToScreenPoint(coord)));
            break;
          case 'MultiPolygon':
            processed.coordinates = geometry.coordinates.map(polygon => 
              polygon.map(ring => ring.map(coord => this._latLngToScreenPoint(coord)))
            );
            break;
          default:
            console.warn('[Atlas] Unsupported geometry type:', geometry.type);
            return null;
        }

        this._featureCache.set(cacheKey, processed);
        return processed;
      }

      _renderPoint(ctx, feature, style) {
        const { x, y } = feature.coordinates;
        ctx.beginPath();
        ctx.arc(x, y, style.radius || 5, 0, 2 * Math.PI);
        ctx.fillStyle = style.fillColor || style.color || '#3388ff';
        ctx.fill();

        if (style.stroke !== false) {
          ctx.strokeStyle = style.color || '#3388ff';
          ctx.lineWidth = style.weight || 2;
          ctx.globalAlpha = style.opacity || 1;
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }

      _renderLineString(ctx, feature, style) {
        const coords = feature.coordinates;
        if (coords.length < 2) return;

        ctx.beginPath();
        ctx.moveTo(coords[0].x, coords[0].y);
        for (let i = 1; i < coords.length; i++) {
          ctx.lineTo(coords[i].x, coords[i].y);
        }

        ctx.strokeStyle = style.color || '#3388ff';
        ctx.lineWidth = style.weight || 3;
        ctx.globalAlpha = style.opacity || 1;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      _renderPolygon(ctx, feature, style) {
        const rings = feature.coordinates;
        if (rings.length === 0) return;

        ctx.beginPath();
        for (let r = 0; r < rings.length; r++) {
          const ring = rings[r];
          if (ring.length < 3) continue;

          ctx.moveTo(ring[0].x, ring[0].y);
          for (let i = 1; i < ring.length; i++) {
            ctx.lineTo(ring[i].x, ring[i].y);
          }
          ctx.closePath();
        }

        if (style.fill !== false) {
          ctx.fillStyle = style.fillColor || style.color || '#3388ff';
          ctx.globalAlpha = style.fillOpacity || 0.2;
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        if (style.stroke !== false) {
          ctx.strokeStyle = style.color || '#3388ff';
          ctx.lineWidth = style.weight || 3;
          ctx.globalAlpha = style.opacity || 1;
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      _pointInPolygon(x, y, rings) {
        let inside = false;

        if (this._pointInRing(x, y, rings[0])) {
          inside = true;

          for (let i = 1; i < rings.length; i++) {
            if (this._pointInRing(x, y, rings[i])) {
              inside = false;
              break;
            }
          }
        }

        return inside;
      }

      _pointInRing(x, y, ring) {
        let inside = false;

        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          const xi = ring[i].x;
          const yi = ring[i].y;
          const xj = ring[j].x;
          const yj = ring[j].y;

          const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }

        return inside;
      }

      _pointOnLine(x, y, line, width) {
        for (let i = 0; i < line.length - 1; i++) {
          const p1 = line[i];
          const p2 = line[i + 1];
          const dx = p2.x - p1.x;
          const dy = p2.y - p1.y;
          const lenSq = dx * dx + dy * dy;

          if (lenSq === 0) continue;

          let t = ((x - p1.x) * dx + (y - p1.y) * dy) / lenSq;
          t = Math.max(0, Math.min(1, t));

          const closeX = p1.x + t * dx;
          const closeY = p1.y + t * dy;
          const distSq = (x - closeX) * (x - closeX) + (y - closeY) * (y - closeY);

          if (distSq < (width / 2) * (width / 2)) return true;
        }

        return false;
      }

      _hitDetect(x, y) {
        for (let i = this._features.length - 1; i >= 0; i--) {
          const feature = this._features[i];
          const processed = this._processFeature(feature);

          if (!processed) continue;

          const style = this._getFeatureStyle(feature);

          switch (processed.type) {
            case 'Point': {
              const dist = Math.hypot(x - processed.coordinates.x, y - processed.coordinates.y);
              if (dist <= (style.radius || 5) + 5) {
                return feature;
              }
              break;
            }
            case 'LineString':
              if (this._pointOnLine(x, y, processed.coordinates, (style.weight || 3) + 10)) {
                return feature;
              }
              break;
            case 'Polygon':
              if (this._pointInPolygon(x, y, processed.coordinates)) {
                return feature;
              }
              break;
          }
        }

        return null;
      }

      _onMouseMove(e) {
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const feature = this._hitDetect(x, y);

        if (this._hoveredFeature && this._hoveredFeature !== feature) {
          this.fire('mouseout', { originalEvent: e, feature: this._hoveredFeature });
          this._hoveredFeature = null;
          this._map.canvas.style.cursor = 'grab';
        }

        if (feature && this._hoveredFeature !== feature) {
          this.fire('mouseover', { originalEvent: e, feature });
          this._hoveredFeature = feature;
          this._map.canvas.style.cursor = 'pointer';
        }

        if (feature) {
          this.fire('mousemove', { originalEvent: e, feature });
        }
      }

      _onMouseOut(e) {
        if (this._hoveredFeature) {
          this.fire('mouseout', { originalEvent: e, feature: this._hoveredFeature });
          this._hoveredFeature = null;
          this._map.canvas.style.cursor = 'grab';
        }
      }

      _onClick(e) {
        const rect = this._map.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const feature = this._hitDetect(x, y);

        if (feature) {
          this.fire('click', { originalEvent: e, feature });
        }
      }

      onAdd() {
        this._features = this._geojson.features || [];

        if (this.options.interactive) {
          this._map.canvas.addEventListener('mousemove', this._onMouseMove);
          this._map.canvas.addEventListener('mouseout', this._onMouseOut);
          this._map.canvas.addEventListener('click', this._onClick);
        }

        // Call onEachFeature callback if provided
        if (this.options.onEachFeature) {
          for (const feature of this._features) {
            this.options.onEachFeature(feature, null);
          }
        }

        this.fire('add');
      }

      onRemove() {
        if (this.options.interactive) {
          this._map.canvas.removeEventListener('mousemove', this._onMouseMove);
          this._map.canvas.removeEventListener('mouseout', this._onMouseOut);
          this._map.canvas.removeEventListener('click', this._onClick);
        }

        this._featureCache.clear();
        this._hitCache.clear();
        this.fire('remove');
      }

      render() {
        if (!this._map) return;

        const { ctx } = this._map;
        const needsRebuild = (
          this._lastRenderZoom !== this._map.zoom ||
          this._lastRenderBearing !== this._map.bearing ||
          this._lastRenderCenter?.lon !== this._map.center.lon ||
          this._lastRenderCenter?.lat !== this._map.center.lat
        );

        if (needsRebuild) {
          this._featureCache.clear();
          this._hitCache.clear();
          this._lastRenderZoom = this._map.zoom;
          this._lastRenderBearing = this._map.bearing;
          this._lastRenderCenter = { ...this._map.center };
        }

        for (const feature of this._features) {
          const processed = this._processFeature(feature);
          if (!processed) continue;

          const style = this._getFeatureStyle(feature);

          switch (processed.type) {
            case 'Point':
              this._renderPoint(ctx, processed, style);
              break;
            case 'LineString':
              this._renderLineString(ctx, processed, style);
              break;
            case 'Polygon':
              this._renderPolygon(ctx, processed, style);
              break;
          }
        }
      }

      setData(geojson) {
        this._geojson = this._normalizeGeoJSON(geojson);
        this._features = this._geojson.features || [];
        this._featureCache.clear();
        this._hitCache.clear();

        if (this._map) {
          this._map.render();
        }

        return this;
      }

      getData() {
        return this._geojson;
      }

      /**
       * Filter features by property
       */
      filterByProperty(propertyName, value) {
        const filtered = this._features.filter(feature => 
          feature.properties && feature.properties[propertyName] === value
        );
        this.setData({
          type: 'FeatureCollection',
          features: filtered
        });
        return this;
      }
    }

    /**
     * HeatmapLayer - Render heatmap from point data
     */
    class HeatmapLayer extends Layer {
      constructor(options = {}) {
        super(options);
        this.data = [];
        this.options = {
          max: options.max || 1,
          radius: options.radius || 25,
          blur: options.blur || 15,
          gradient: options.gradient || {
            0.0: 'blue',
            0.25: 'cyan',
            0.5: 'lime',
            0.75: 'yellow',
            1.0: 'red'
          },
          opacity: options.opacity || 0.7,
          ...options
        };

        this._canvas = null;
        this._ctx = null;
      }

      setData(data) {
        // Data format: [{ lat, lon, intensity }, ...]
        this.data = data || [];
        if (this._map) {
          this._map.render();
        }
        return this;
      }

      _createGradient() {
        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 256, 1);

        for (const [pos, color] of Object.entries(this.options.gradient)) {
          gradient.addColorStop(parseFloat(pos), color);
        }

        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 256, 1);

        return canvas.toDataURL();
      }

      render() {
        if (!this._map || this.data.length === 0) return;

        const { ctx, canvas, dpr } = this._map;
        const w = canvas.width / dpr;
        const h = canvas.height / dpr;

        // Create off-screen canvas for heatmap
        const offCanvas = document.createElement('canvas');
        offCanvas.width = canvas.width;
        offCanvas.height = canvas.height;
        const offCtx = offCanvas.getContext('2d');

        // Draw points as blurred circles
        offCtx.fillStyle = 'rgba(0, 0, 0, 1)';
        offCtx.filter = `blur(${this.options.blur}px)`;

        for (const point of this.data) {
          const screenPoint = this._map.latLngToContainerPoint(point);
          const intensity = Math.min(1, (point.intensity || 1) / this.options.max);
          const radius = this.options.radius * intensity;

          offCtx.globalAlpha = intensity;
          offCtx.beginPath();
          offCtx.arc(screenPoint.x * dpr, screenPoint.y * dpr, radius * dpr, 0, Math.PI * 2);
          offCtx.fill();
        }

        // Apply gradient coloring using ImageData
        const imageData = offCtx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;

        const gradientCanvas = document.createElement('canvas');
        gradientCanvas.width = 256;
        gradientCanvas.height = 1;
        const gradCtx = gradientCanvas.getContext('2d');
        const gradient = gradCtx.createLinearGradient(0, 0, 256, 1);

        for (const [pos, color] of Object.entries(this.options.gradient)) {
          gradient.addColorStop(parseFloat(pos), color);
        }

        gradCtx.fillStyle = gradient;
        gradCtx.fillRect(0, 0, 256, 1);

        const gradientData = gradCtx.getImageData(0, 0, 256, 1).data;

        // Apply gradient to heatmap
        for (let i = 0; i < data.length; i += 4) {
          const alpha = data[i + 3];
          const index = Math.floor((alpha / 255) * 255) * 4;

          data[i] = gradientData[index];
          data[i + 1] = gradientData[index + 1];
          data[i + 2] = gradientData[index + 2];
          data[i + 3] = Math.round(alpha * this.options.opacity);
        }

        offCtx.putImageData(imageData, 0, 0);

        // Draw to main canvas
        ctx.globalAlpha = this.options.opacity;
        ctx.drawImage(offCanvas, 0, 0);
        ctx.globalAlpha = 1;
      }

      onAdd() {
        this.fire('add');
      }

      onRemove() {
        this.data = [];
        this.fire('remove');
      }
    }

    // ============================================================
    // MARKER CLUSTERING
    // ============================================================

    /**
     * MarkerCluster - Clusters markers for better performance
     */
    class MarkerCluster {
      constructor(options = {}) {
        this.markers = [];
        this.clusters = [];
        this.options = {
          maxClusterRadius: options.maxClusterRadius || 50,
          minClusterSize: options.minClusterSize || 2,
          zoomToBoundsOnClick: options.zoomToBoundsOnClick !== false,
          ...options
        };
        this._map = null;
      }

      addMarker(marker) {
        this.markers.push(marker);
        return this;
      }

      addMarkers(markers) {
        this.markers.push(...markers);
        return this;
      }

      /**
       * Cluster markers based on current zoom level
       */
      cluster() {
        this.clusters = [];
        const clustered = new Set();

        for (let i = 0; i < this.markers.length; i++) {
          if (clustered.has(i)) continue;

          const marker = this.markers[i];
          const clusterMarkers = [marker];
          clustered.add(i);

          // Find nearby markers
          for (let j = i + 1; j < this.markers.length; j++) {
            if (clustered.has(j)) continue;

            const otherMarker = this.markers[j];
            const distance = GISUtils.getDistance(marker.getLatLng(), otherMarker.getLatLng());

            if (distance < this.options.maxClusterRadius / Math.pow(2, this._map.zoom - 10)) {
              clusterMarkers.push(otherMarker);
              clustered.add(j);
            }
          }

          if (clusterMarkers.length >= this.options.minClusterSize) {
            const avgLat = clusterMarkers.reduce((sum, m) => sum + m.getLatLng().lat, 0) / clusterMarkers.length;
            const avgLon = clusterMarkers.reduce((sum, m) => sum + m.getLatLng().lon, 0) / clusterMarkers.length;

            this.clusters.push({
              center: { lat: avgLat, lon: avgLon },
              count: clusterMarkers.length,
              markers: clusterMarkers
            });
          } else {
            for (const m of clusterMarkers) {
              this.clusters.push({ marker: m });
            }
          }
        }

        return this.clusters;
      }

      addTo(map) {
        this._map = map;
        return this;
      }

      render(ctx) {
        if (!this._map) return;

        for (const cluster of this.clusters) {
          if (cluster.marker) {
            // Single marker
            cluster.marker.render();
          } else {
            // Cluster
            const screenPoint = this._map.latLngToContainerPoint(cluster.center);

            ctx.save();
            ctx.fillStyle = 'rgba(0, 120, 168, 0.8)';
            ctx.beginPath();
            ctx.arc(screenPoint.x, screenPoint.y, 22, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(cluster.count, screenPoint.x, screenPoint.y);

            ctx.restore();
          }
        }
      }
    }

    // ============================================================
    // DRAWING TOOLS
    // ============================================================

    /**
     * DrawingManager - Tools for drawing shapes on map
     */
    class DrawingManager {
      constructor(map, options = {}) {
        this._map = map;
        this.isDrawing = false;
        this.drawingMode = null;
        this.currentShape = null;
        this.shapes = [];

        this.options = {
          color: options.color || '#ff0000',
          fillColor: options.fillColor || '#ff000033',
          weight: options.weight || 2,
          ...options
        };

        this._setupEventListeners();
      }

      _setupEventListeners() {
        this._map.canvas.addEventListener('mousedown', (e) => this._onMouseDown(e));
        this._map.canvas.addEventListener('mousemove', (e) => this._onMouseMove(e));
        this._map.canvas.addEventListener('mouseup', (e) => this._onMouseUp(e));
        this._map.canvas.addEventListener('dblclick', (e) => this._onDoubleClick(e));
      }

      setDrawingMode(mode) {
        // 'circle', 'rectangle', 'polyline', 'polygon', null
        this.drawingMode = mode;
        if (mode) {
          this._map.container.classList.add('drawing');
          this._map.disableHandler('dragPan');
          this.currentShape = { points: [] };
        } else {
          this._map.container.classList.remove('drawing');
          this._map.enableHandler('dragPan');
        }
      }

      _onMouseDown(e) {
        if (!this.drawingMode || this._map.isDragging) return;

        const rect = this._map.canvas.getBoundingClientRect();
        const point = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        const latlng = this._map.screenToLatLon(point.x, point.y);
        this.currentShape.points.push(latlng);

        this._map.render();
      }

      _onMouseMove(e) {
        if (!this.drawingMode || this.currentShape.points.length === 0) return;

        this._map.render();
      }

      _onMouseUp(e) {
        // Handle mouse up logic if needed
      }

      _onDoubleClick(e) {
        if (!this.drawingMode || this.currentShape.points.length < 2) return;

        this.shapes.push(this.currentShape);
        this._map.fire('drawingcomplete', { shape: this.currentShape, mode: this.drawingMode });

        this.currentShape = { points: [] };
        this._map.render();
      }

      getShapes() {
        return this.shapes;
      }

      clearShapes() {
        this.shapes = [];
        this._map.render();
      }

      renderShapes(ctx) {
        for (const shape of this.shapes) {
          if (!shape.points || shape.points.length < 2) continue;

          const points = shape.points.map(latlng => this._map.latLngToContainerPoint(latlng));

          ctx.strokeStyle = this.options.color;
          ctx.fillStyle = this.options.fillColor;
          ctx.lineWidth = this.options.weight;

          ctx.beginPath();
          ctx.moveTo(points[0].x, points[0].y);

          for (let i = 1; i < points.length; i++) {
            ctx.lineTo(points[i].x, points[i].y);
          }

          if (shape.closed) {
            ctx.closePath();
          }

          ctx.stroke();
          if (shape.closed) {
            ctx.fill();
          }
        }
      }
    }

    // ============================================================
    // MEASUREMENT TOOLS
    // ============================================================

    /**
     * MeasurementTool - Measure distances and areas
     */
    class MeasurementTool {
      constructor(map) {
        this._map = map;
        this.isActive = false;
        this.points = [];
        this.distances = [];
      }

      start() {
        this.isActive = true;
        this.points = [];
        this.distances = [];
        this._map.disableHandler('dragPan');
        this._setupMeasurementHandlers();
      }

      stop() {
        this.isActive = false;
        this.points = [];
        this.distances = [];
        this._map.enableHandler('dragPan');
        this._removeMeasurementHandlers();
      }

      _setupMeasurementHandlers() {
        this._handleClick = (e) => this._onClick(e);
        this._map.canvas.addEventListener('click', this._handleClick);
      }

      _removeMeasurementHandlers() {
        this._map.canvas.removeEventListener('click', this._handleClick);
      }

      _onClick(e) {
        const rect = this._map.canvas.getBoundingClientRect();
        const point = {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };

        const latlng = this._map.screenToLatLon(point.x, point.y);
        this.points.push(latlng);

        if (this.points.length > 1) {
          const distance = GISUtils.getDistance(
            this.points[this.points.length - 2],
            this.points[this.points.length - 1]
          );
          this.distances.push(distance);
        }

        this._map.fire('measurement', {
          points: this.points,
          totalDistance: this.getTotalDistance(),
          lastSegment: this.distances[this.distances.length - 1] || 0
        });

        this._map.render();
      }

      getTotalDistance() {
        return this.distances.reduce((a, b) => a + b, 0);
      }

      getArea() {
        if (this.points.length < 3) return 0;
        // Close the polygon for area calculation
        const closedPoints = [...this.points, this.points[0]];
        return GISUtils.getPolygonArea(closedPoints.map(p => [p.lat, p.lon]));
      }

      render(ctx) {
        if (this.points.length === 0) return;

        const screenPoints = this.points.map(p => this._map.latLngToContainerPoint(p));

        // Draw line
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(screenPoints[0].x, screenPoints[0].y);

        for (let i = 1; i < screenPoints.length; i++) {
          ctx.lineTo(screenPoints[i].x, screenPoints[i].y);
        }

        ctx.stroke();

        // Draw points
        for (const point of screenPoints) {
          ctx.fillStyle = '#ff0000';
          ctx.beginPath();
          ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // ============================================================
    // CONTROL SYSTEM
    // ============================================================

    class Control {
      constructor(options = {}) {
        this.options = {
          position: options.position || 'top-left'
        };
        this._map = null;
        this._container = null;
        this._events = {};
      }

      on(type, fn) {
        if (!this._events[type]) {
          this._events[type] = [];
        }
        this._events[type].push(fn);
        return this;
      }

      off(type, fn) {
        if (!this._events[type]) return this;
        if (!fn) {
          this._events[type] = [];
        } else {
          this._events[type] = this._events[type].filter(cb => cb !== fn);
        }
        return this;
      }

      fire(type, data = {}) {
        if (!this._events[type]) return;
        data.type = type;
        data.target = this;
        this._events[type].forEach(fn => fn(data));
      }

      onAdd() {
        return document.createElement('div');
      }

      onRemove() {}

      addTo(map) {
        this.remove();
        this._map = map;
        this._container = this.onAdd();
        this._container.controlInstance = this;
        this._addToContainer();
        return this;
      }

      remove() {
        if (!this._map) return this;

        this.onRemove();

        if (this._container && this._container.parentNode) {
          this._container.parentNode.removeChild(this._container);
        }

        this._map = null;
        this._container = null;
        return this;
      }

      getContainer() {
        return this._container;
      }

      _addToContainer() {
        if (!this._map || !this._container) return;

        const position = this.options.position;
        let container = this._map._controlCorners[position];

        if (!container) {
          container = document.createElement('div');
          container.className = `atlas-control-container atlas-control-${position}`;

          if (position.includes('top') || position.includes('bottom')) {
            container.classList.add('atlas-control-vertical');
          } else {
            container.classList.add('atlas-control-horizontal');
          }

          this._map.container.appendChild(container);
          this._map._controlCorners[position] = container;
        }

        container.appendChild(this._container);
      }
    }

    // [CONTINUE IN NEXT MESSAGE - Character limit reached]

    /**
     * ZoomControl - Zoom buttons
     */
    class ZoomControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = {
          ...this.options,
          zoomInTitle: options.zoomInTitle || 'Zoom in',
          zoomOutTitle: options.zoomOutTitle || 'Zoom out'
        };
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-zoom-control';

        const zoomInBtn = document.createElement('button');
        zoomInBtn.className = 'control-btn';
        zoomInBtn.title = this.options.zoomInTitle;
        zoomInBtn.setAttribute('aria-label', this.options.zoomInTitle);
        zoomInBtn.textContent = '+';
        zoomInBtn.onclick = () => {
          if (this._map) {
            this._map.stopAnimations();
            this._map.setZoom(this._map.getZoom() + 1);
          }
        };

        const zoomOutBtn = document.createElement('button');
        zoomOutBtn.className = 'control-btn';
        zoomOutBtn.title = this.options.zoomOutTitle;
        zoomOutBtn.setAttribute('aria-label', this.options.zoomOutTitle);
        zoomOutBtn.textContent = '−';
        zoomOutBtn.onclick = () => {
          if (this._map) {
            this._map.stopAnimations();
            this._map.setZoom(this._map.getZoom() - 1);
          }
        };

        container.appendChild(zoomInBtn);
        container.appendChild(zoomOutBtn);

        this._zoomInBtn = zoomInBtn;
        this._zoomOutBtn = zoomOutBtn;

        return container;
      }

      onRemove() {}

      _update() {
        if (!this._map || !this._zoomInBtn || !this._zoomOutBtn) return;

        const minZoom = this._map.getBaseLayer() ? this._map.getBaseLayer().getMinZoom() : 0;
        const maxZoom = this._map.getBaseLayer() ? this._map.getBaseLayer().getMaxZoom() : 18;
        const currentZoom = this._map.getZoom();

        this._zoomInBtn.disabled = currentZoom >= maxZoom;
        this._zoomOutBtn.disabled = currentZoom <= minZoom;
      }
    }

    /**
     * LayerControl - Switch between layers
     */
    class LayerControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = {
          ...this.options,
          title: options.title || 'Toggle layer'
        };
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-layer-control';

        const subdomains = ['a', 'b', 'c'];
        const randomSubdomain = subdomains[Math.floor(Math.random() * subdomains.length)];

        this._osmLayer = new TileLayer(
          `https://${randomSubdomain}.tile.openstreetmap.org/{z}/{x}/{y}.png`,
          {
            minZoom: 0,
            maxZoom: 19,
            attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
            background: "#e6e6e6",
            supportsRetina: true,
            maxCacheSize: 500
          }
        );

        this._esriLayer = new TileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          {
            minZoom: 0,
            maxZoom: 19,
            attribution: 'Tiles © <a href="https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer" target="_blank" rel="noopener noreferrer">Esri World Imagery</a>',
            background: "#000000",
            supportsRetina: false,
            maxCacheSize: 400
          }
        );

        const toggleBtn = document.createElement('button');
        toggleBtn.className = 'control-btn';
        toggleBtn.title = this.options.title;
        toggleBtn.setAttribute('aria-label', this.options.title);
        toggleBtn.textContent = '🌐';
        toggleBtn.onclick = () => {
          if (this._map) {
            const current = this._map.getBaseLayer();
            if (current === this._osmLayer) {
              this._map.setBaseLayer(this._esriLayer);
            } else {
              this._map.setBaseLayer(this._osmLayer);
            }
          }
        };

        container.appendChild(toggleBtn);
        this._toggleBtn = toggleBtn;

        return container;
      }

      onRemove() {}
    }

    /**
     * FullscreenControl - Toggle fullscreen
     */
    class FullscreenControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = {
          ...this.options,
          title: options.title || 'Toggle fullscreen'
        };
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-fullscreen-control';

        const fullscreenBtn = document.createElement('button');
        fullscreenBtn.className = 'control-btn';
        fullscreenBtn.title = this.options.title;
        fullscreenBtn.setAttribute('aria-label', this.options.title);
        fullscreenBtn.textContent = '⛶';
        fullscreenBtn.onclick = () => {
          if (!document.fullscreenElement) {
            this._map.container.requestFullscreen().catch(err => {
              console.warn(`[Atlas] Error attempting to enable fullscreen: ${err.message}`);
            });
          } else {
            document.exitFullscreen().catch(err => {
              console.warn(`[Atlas] Error attempting to exit fullscreen: ${err.message}`);
            });
          }
        };

        container.appendChild(fullscreenBtn);
        this._fullscreenBtn = fullscreenBtn;

        return container;
      }

      onRemove() {}
    }

    /**
     * ScaleControl - Show map scale
     */
    class ScaleControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = {
          ...this.options,
          maxWidth: options.maxWidth || 150,
          unit: options.unit || 'metric'
        };
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-scale-control scale-bar-container';

        this._scaleBar = document.createElement('div');
        this._scaleBar.className = 'scale-bar';

        this._scaleText = document.createElement('div');
        this._scaleText.id = 'scale-text';
        this._scaleText.dataset.unit = this.options.unit;

        container.appendChild(this._scaleBar);
        container.appendChild(this._scaleText);

        this._toggleUnit = () => {
          this._scaleText.dataset.unit = this._scaleText.dataset.unit === 'metric' ? 'imperial' : 'metric';
          this._update();
        };

        this._scaleText.addEventListener('click', this._toggleUnit);

        return container;
      }

      onRemove() {
        if (this._scaleText) {
          this._scaleText.removeEventListener('click', this._toggleUnit);
        }
      }

      _update() {
        if (!this._map || !this._scaleBar || !this._scaleText) return;

        const mPerPx = GISUtils.getResolution(this._map.getCenter().lat, this._map.getZoom());
        const targetMeters = mPerPx * this.options.maxWidth;

        const pow = Math.pow(10, Math.floor(Math.log10(targetMeters)));
        const base = targetMeters / pow;
        const niceBase = base >= 5 ? 5 : base >= 2 ? 2 : 1;
        const niceMeters = niceBase * pow;

        const widthPx = Math.max(20, Math.min(this.options.maxWidth, niceMeters / mPerPx));

        this._scaleBar.style.width = `${widthPx}px`;

        let displayText;
        if (this._scaleText.dataset.unit === "metric") {
          displayText = GISUtils.formatDistance(niceMeters);
        } else {
          const feet = niceMeters * 3.28084;
          displayText = feet < 5280 ? Math.round(feet) + " ft" : (feet / 5280).toFixed(1) + " mi";
        }

        this._scaleText.textContent = displayText;
      }
    }

    /**
     * AttributionControl - Show attribution
     */
    class AttributionControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = {
          ...this.options,
          prefix: options.prefix || ''
        };
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-attribution-control';
        container.id = 'attribution';
        container.innerHTML = this.options.prefix;
        this._container = container;
        return container;
      }

      onRemove() {}

      _update() {
        if (!this._map || !this._container) return;

        const attribution = this._map.getBaseLayer() ? this._map.getBaseLayer().getAttribution() : '';
        this._container.innerHTML = this.options.prefix + 
          (this.options.prefix && attribution ? ' | ' : '') + 
          attribution;
      }
    }

    /**
     * CompassControl - Reset bearing to north
     */
    class CompassControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = {
          ...this.options,
          title: options.title || 'Reset North'
        };
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-compass-control';

        const compassBtn = document.createElement('button');
        compassBtn.id = 'compass';
        compassBtn.className = 'control-btn';
        compassBtn.title = this.options.title;
        compassBtn.setAttribute('aria-label', this.options.title);
        compassBtn.textContent = 'N';
        compassBtn.style.display = 'none';

        compassBtn.onclick = () => {
          if (this._map) {
            const w = this._map.canvas.width / this._map.dpr;
            const h = this._map.canvas.height / this._map.dpr;
            this._map.animateZoomRotateAbout(w / 2, h / 2, this._map.getZoom(), 0, CONSTANTS.SNAP_DURATION);
          }
        };

        compassBtn.onmouseenter = () => { 
          compassBtn.style.background = "rgba(240, 240, 240, 0.95)"; 
        };
        compassBtn.onmouseleave = () => { 
          compassBtn.style.background = "rgba(255, 255, 255, 0.9)"; 
        };
        compassBtn.onmousedown = () => { 
          compassBtn.style.transform = `scale(0.98) rotate(${-this._map.getBearing() * CONSTANTS.RAD2DEG}deg)`; 
        };
        compassBtn.onmouseup = () => { 
          compassBtn.style.transform = `rotate(${-this._map.getBearing() * CONSTANTS.RAD2DEG}deg)`; 
        };

        container.appendChild(compassBtn);
        this._compassBtn = compassBtn;

        return container;
      }

      onRemove() {}

      _update() {
        if (!this._compassBtn || !this._map) return;

        const visible = Math.abs(this._map.getBearing()) > 0.001;
        this._compassBtn.style.display = visible ? "block" : "none";
        this._compassBtn.style.transform = `rotate(${-this._map.getBearing() * CONSTANTS.RAD2DEG}deg)`;
      }
    }

    /**
     * ResetZoomControl - Reset to default view
     */
    class ResetZoomControl extends Control {
      constructor(options = {}) {
        super(options);
        this.options = {
          ...this.options,
          title: options.title || 'Reset Zoom'
        };
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-reset-zoom-control';

        const resetBtn = document.createElement('button');
        resetBtn.id = 'reset-zoom';
        resetBtn.className = 'control-btn';
        resetBtn.title = this.options.title;
        resetBtn.setAttribute('aria-label', this.options.title);
        resetBtn.textContent = '⤢';

        resetBtn.onclick = () => {
          if (this._map) {
            this._map.flyTo({ 
              center: CONFIG.defaultCenter, 
              zoom: CONFIG.defaultZoom, 
              duration: CONSTANTS.SNAP_DURATION 
            });
          }
        };

        resetBtn.onmouseenter = () => { 
          resetBtn.style.background = "rgba(240, 240, 240, 0.95)"; 
        };
        resetBtn.onmouseleave = () => { 
          resetBtn.style.background = "rgba(255, 255, 255, 0.9)"; 
        };
        resetBtn.onmousedown = () => { 
          resetBtn.style.transform = "scale(0.98)"; 
        };
        resetBtn.onmouseup = () => { 
          resetBtn.style.transform = "scale(1)"; 
        };

        container.appendChild(resetBtn);
        this._resetBtn = resetBtn;

        return container;
      }

      onRemove() {}
    }

    /**
     * DrawingControl - Toggle drawing mode
     */
    class DrawingControl extends Control {
      constructor(options = {}) {
        super(options);
        this._drawingManager = null;
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'drawing-toolbar';

        const modes = [
          { id: 'circle', label: '◯' },
          { id: 'rectangle', label: '▭' },
          { id: 'polyline', label: '/\\' },
          { id: 'polygon', label: '▱' },
          { id: 'clear', label: '✕' }
        ];

        for (const mode of modes) {
          const btn = document.createElement('button');
          btn.className = 'control-btn';
          btn.textContent = mode.label;
          btn.title = mode.id;

          if (mode.id === 'clear') {
            btn.onclick = () => {
              if (this._drawingManager) {
                this._drawingManager.clearShapes();
              }
            };
          } else {
            btn.onclick = () => {
              if (this._drawingManager) {
                const isActive = this._drawingManager.drawingMode === mode.id;
                this._drawingManager.setDrawingMode(isActive ? null : mode.id);
                btn.classList.toggle('active', !isActive);
              }
            };
          }

          container.appendChild(btn);
        }

        return container;
      }

      setDrawingManager(manager) {
        this._drawingManager = manager;
      }
    }

    /**
     * MeasurementControl - Measurement tool
     */
    class MeasurementControl extends Control {
      constructor(options = {}) {
        super(options);
        this._measurementTool = null;
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'atlas-measurement-control';

        const btn = document.createElement('button');
        btn.className = 'control-btn';
        btn.textContent = '📏';
        btn.title = 'Measure distance';

        btn.onclick = () => {
          if (this._measurementTool) {
            if (this._measurementTool.isActive) {
              this._measurementTool.stop();
              btn.classList.remove('active');
            } else {
              this._measurementTool.start();
              btn.classList.add('active');
            }
          }
        };

        container.appendChild(btn);

        return container;
      }

      setMeasurementTool(tool) {
        this._measurementTool = tool;
      }
    }

    /**
     * LegendControl - Show legend
     */
    class LegendControl extends Control {
      constructor(items = [], options = {}) {
        super(options);
        this.items = items;
      }

      onAdd() {
        const container = document.createElement('div');
        container.className = 'legend-control';

        for (const item of this.items) {
          const itemEl = document.createElement('div');
          itemEl.className = 'legend-item';

          const colorEl = document.createElement('div');
          colorEl.className = 'legend-color';
          colorEl.style.backgroundColor = item.color || '#000';

          const labelEl = document.createElement('span');
          labelEl.textContent = item.label || '';

          itemEl.appendChild(colorEl);
          itemEl.appendChild(labelEl);

          if (item.onClick) {
            itemEl.onclick = item.onClick;
          }

          container.appendChild(itemEl);
        }

        return container;
      }
    }

    // ============================================================
    // HANDLER SYSTEM
    // ============================================================

    class Handler {
      constructor(map) {
        this._map = map;
        this._enabled = false;
        this._eventListeners = {};
      }

      enable() {
        if (this._enabled) return this;
        this._enabled = true;
        this._addEvents();
        return this;
      }

      disable() {
        if (!this._enabled) return this;
        this._enabled = false;
        this._removeEvents();
        return this;
      }

      toggle() {
        return this._enabled ? this.disable() : this.enable();
      }

      isEnabled() {
        return this._enabled;
      }

      _addEvents() {}
      _removeEvents() {}

      destroy() {
        this.disable();
        this._eventListeners = {};
      }
    }

    /**
     * DragPanHandler - Pan by dragging
     */
    class DragPanHandler extends Handler {
      constructor(map) {
        super(map);
        this._isDragging = false;
        this._dragStart = null;
        this._moveSamples = [];
      }

      _addEvents() {
        this._map.canvas.addEventListener('mousedown', this._onMouseDown = this._onMouseDown.bind(this));
        this._map.canvas.addEventListener('touchstart', this._onTouchStart = this._onTouchStart.bind(this), { passive: false });
      }

      _removeEvents() {
        this._map.canvas.removeEventListener('mousedown', this._onMouseDown);
        this._map.canvas.removeEventListener('touchstart', this._onTouchStart);
        this._removeMoveEvents();
      }

      _removeMoveEvents() {
        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
        document.removeEventListener('touchmove', this._onTouchMove);
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);
      }

      _onMouseDown(e) {
        if (e.button !== 0) return;
        this._startDrag(e.clientX, e.clientY);
        document.addEventListener('mousemove', this._onMouseMove = this._onMouseMove.bind(this));
        document.addEventListener('mouseup', this._onMouseUp = this._onMouseUp.bind(this));
      }

      _onMouseMove(e) {
        if (!this._isDragging) return;
        e.preventDefault();

        const dx = e.clientX - this._dragStart.x;
        const dy = e.clientY - this._dragStart.y;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;

        this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy, this._map.zoom, this._map.bearing, this._dragStart.center);
        this._pushVelocitySample(e.clientX, e.clientY);
        this._map.render();
      }

      _onMouseUp() {
        this._endDrag();
      }

      _onTouchStart(e) {
        if (e.touches.length !== 1) return;
        e.preventDefault();
        this._startDrag(e.touches[0].clientX, e.touches[0].clientY);
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }

      _onTouchMove(e) {
        if (!this._isDragging || e.touches.length !== 1) return;
        e.preventDefault();

        const dx = e.touches[0].clientX - this._dragStart.x;
        const dy = e.touches[0].clientY - this._dragStart.y;
        const w = this._map.canvas.width / this._map.dpr;
        const h = this._map.canvas.height / this._map.dpr;

        this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy, this._map.zoom, this._map.bearing, this._dragStart.center);
        this._pushVelocitySample(e.touches[0].clientX, e.touches[0].clientY);
        this._map.render();
      }

      _onTouchEnd() {
        this._endDrag();
      }

      _startDrag(clientX, clientY) {
        this._isDragging = true;
        this._map.stopAnimations();
        this._map.isDragging = true;
        this._map.container.classList.add('dragging');

        this._dragStart = {
          x: clientX,
          y: clientY,
          center: { ...this._map.center }
        };

        this._moveSamples = [];
        this._pushVelocitySample(clientX, clientY);
      }

      _endDrag() {
        if (!this._isDragging) return;

        this._isDragging = false;
        this._map.isDragging = false;
        this._map.container.classList.remove('dragging');

        const { vx, vy } = this._computeVelocity();
        this._startInertia(vx, vy);
        this._removeMoveEvents();
      }

      _pushVelocitySample(x, y) {
        const t = performance.now();
        this._moveSamples.push({ t, x, y });

        const cutoff = t - CONSTANTS.VELOCITY_WINDOW_MS;
        while (this._moveSamples.length && this._moveSamples[0].t < cutoff) {
          this._moveSamples.shift();
        }
      }

      _computeVelocity() {
        if (this._moveSamples.length < 2) {
          return { vx: 0, vy: 0 };
        }

        const last = this._moveSamples[this._moveSamples.length - 1];
        let i = this._moveSamples.length - 2;

        while (i > 0 && last.t - this._moveSamples[i].t < CONSTANTS.VELOCITY_WINDOW_MS * 0.5) {
          i--;
        }

        const ref = this._moveSamples[i];
        const dt = Math.max(1, last.t - ref.t);

        return {
          vx: (last.x - ref.x) / dt,
          vy: (last.y - ref.y) / dt
        };
      }

      _startInertia(vx, vy) {
        const speed = Math.hypot(vx, vy);
        if (speed < CONSTANTS.INERTIA_STOP_SPEED) return;

        let lastT = performance.now();

        const step = () => {
          const now = performance.now();
          const dt = now - lastT;
          lastT = now;

          const dx = vx * dt;
          const dy = vy * dt;
          const w = this._map.canvas.width / this._map.dpr;
          const h = this._map.canvas.height / this._map.dpr;

          this._map.center = this._map.screenToLatLon(w / 2 - dx, h / 2 - dy);

          const vmag = Math.hypot(vx, vy);
          const newVmag = Math.max(0, vmag - CONSTANTS.INERTIA_DECEL * dt);

          if (newVmag <= CONSTANTS.INERTIA_STOP_SPEED) {
            this._map.render();
            this._map._inertiaRAF = null;
            this._map.fire('moveend');
            return;
          }

          const s = newVmag / (vmag || 1);
          vx *= s;
          vy *= s;

          this._map.render();
          this._map._inertiaRAF = requestAnimationFrame(step);
        };

        this._map._inertiaRAF = requestAnimationFrame(step);
      }
    }

    /**
     * ScrollZoomHandler - Zoom with mouse wheel
     */
    class ScrollZoomHandler extends Handler {
      constructor(map) {
        super(map);
      }

      _addEvents() {
        this._map.canvas.addEventListener('wheel', this._onWheel = this._onWheel.bind(this), { passive: false });
      }

      _removeEvents() {
        this._map.canvas.removeEventListener('wheel', this._onWheel);
      }

      _onWheel(e) {
        e.preventDefault();
        const dz = (e.deltaY < 0 ? CONSTANTS.WHEEL_ZOOM_STEP : -CONSTANTS.WHEEL_ZOOM_STEP);
        this._map.smoothZoomAt(e.clientX, e.clientY, dz);
      }
    }

    /**
     * DoubleClickZoomHandler - Zoom on double click
     */
    class DoubleClickZoomHandler extends Handler {
      constructor(map) {
        super(map);
        this._lastClickTime = 0;
        this._lastClickPos = { x: 0, y: 0 };
      }

      _addEvents() {
        this._map.canvas.addEventListener('dblclick', this._onDoubleClick = this._onDoubleClick.bind(this));
      }

      _removeEvents() {
        this._map.canvas.removeEventListener('dblclick', this._onDoubleClick);
      }

      _onDoubleClick(e) {
        e.preventDefault();
        this._map.animateZoomRotateAbout(
          e.clientX, 
          e.clientY, 
          this._map.getZoom() + 1, 
          this._map.getBearing(), 
          CONSTANTS.TAP_ZOOM_DURATION
        );
      }
    }

    /**
     * TouchZoomRotateHandler - Pinch zoom and rotation
     */
    class TouchZoomRotateHandler extends Handler {
      constructor(map) {
        super(map);
        this._isPinching = false;
        this._pinchStartDist = 0;
        this._pinchStartAngle = 0;
        this._pinchStartZoom = map.getZoom();
        this._pinchStartBearing = map.getBearing();
        this._pinchStartTime = 0;
        this._pinchLastCenter = null;
        this._pinchMoved = false;
        this._pinchAnchorLL = null;
      }

      _addEvents() {
        this._map.canvas.addEventListener('touchstart', this._onTouchStart = this._onTouchStart.bind(this), { passive: false });
      }

      _removeEvents() {
        this._map.canvas.removeEventListener('touchstart', this._onTouchStart);
        this._removeMoveEvents();
      }

      _removeMoveEvents() {
        document.removeEventListener('touchmove', this._onTouchMove);
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);
      }

      _onTouchStart(e) {
        if (e.touches.length < 2) return;
        e.preventDefault();
        this._startPinch(e);
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }

      _startPinch(e) {
        this._map.stopAnimations();
        this._isPinching = true;

        const t1 = e.touches[0];
        const t2 = e.touches[1];

        this._pinchStartDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        this._pinchStartAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        this._pinchStartZoom = this._map.getZoom();
        this._pinchStartBearing = this._map.getBearing();
        this._pinchStartTime = performance.now();
        this._pinchLastCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
        this._pinchAnchorLL = this._map.screenToLatLon(
          this._pinchLastCenter.x, 
          this._pinchLastCenter.y, 
          this._map.getZoom(), 
          this._map.getBearing(), 
          this._map.getCenter()
        );
        this._pinchMoved = false;
      }

      _onTouchMove(e) {
        if (!this._isPinching || e.touches.length < 2) return;
        e.preventDefault();

        const t1 = e.touches[0];
        const t2 = e.touches[1];

        const dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
        const angle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        const center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };

        const targetZoom = this._pinchStartZoom + Math.log2(dist / Math.max(1, this._pinchStartDist));
        const deltaAngle = normalizeAngle(angle - this._pinchStartAngle);
        const targetBearing = normalizeAngle(this._pinchStartBearing + deltaAngle);

        if (Math.abs(Math.log(dist / Math.max(1, this._pinchStartDist))) > 
            Math.log(1 + CONSTANTS.TWO_FINGER_TAP_MOVE_THRESH / Math.max(1, this._pinchStartDist)) ||
            Math.abs(deltaAngle) > CONSTANTS.ROTATE_MOVE_THRESH_RAD) {
          this._pinchMoved = true;
        }

        this._map.applyZoomRotateAbout(center.x, center.y, targetZoom, targetBearing, this._pinchAnchorLL);
        this._pinchLastCenter = center;
        this._map.render();
      }

      _onTouchEnd(e) {
        if (!this._isPinching) return;

        const dt = performance.now() - this._pinchStartTime;

        if (e.touches.length === 0 && dt <= CONSTANTS.TWO_FINGER_TAP_MAX_DELAY && !this._pinchMoved) {
          const ax = this._pinchLastCenter ? this._pinchLastCenter.x : (this._map.canvas.width / this._map.dpr) / 2;
          const ay = this._pinchLastCenter ? this._pinchLastCenter.y : (this._map.canvas.height / this._map.dpr) / 2;
          this._map.animateZoomRotateAbout(ax, ay, this._map.getZoom() - 1, this._map.getBearing(), CONSTANTS.TAP_ZOOM_DURATION);
        }

        if (e.touches.length < 2) {
          this._isPinching = false;
          this._removeMoveEvents();
        }
      }
    }

    /**
     * KeyboardPanHandler - Keyboard navigation
     */
    class KeyboardPanHandler extends Handler {
      constructor(map) {
        super(map);
      }

      _addEvents() {
        window.addEventListener('keydown', this._onKeyDown = this._onKeyDown.bind(this));
      }

      _removeEvents() {
        window.removeEventListener('keydown', this._onKeyDown);
      }

      _onKeyDown(e) {
        let dx = 0;
        let dy = 0;
        const panStepPx = 100;

        if (e.key === "ArrowUp") {
          dy = panStepPx;
        } else if (e.key === "ArrowDown") {
          dy = -panStepPx;
        } else if (e.key === "ArrowLeft") {
          dx = panStepPx;
        } else if (e.key === "ArrowRight") {
          dx = -panStepPx;
        } else if (e.key.toLowerCase() === "n") {
          const w = this._map.canvas.width / this._map.dpr;
          const h = this._map.canvas.height / this._map.dpr;
          this._map.animateZoomRotateAbout(w / 2, h / 2, this._map.getZoom(), 0, CONSTANTS.SNAP_DURATION);
          return;
        } else if (e.key === "r") {
          this._map.setBearing(this._map.getBearing() + CONSTANTS.DEG2RAD * 15);
          return;
        } else if (e.key === "l") {
          this._map.setBearing(this._map.getBearing() - CONSTANTS.DEG2RAD * 15);
          return;
        } else if (e.key === "s") {
          const nextLayer = this._map.getBaseLayer() && 
            this._map.getBaseLayer().urlTemplate && 
            this._map.getBaseLayer().urlTemplate.includes('arcgisonline') ? 'OSM' : 'ESRI';

          const layerConfig = LAYERS[nextLayer];
          if (layerConfig) {
            const urlTemplate = nextLayer === "ESRI" ?
              "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}" :
              "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";

            const subdomains = ['a', 'b', 'c'];
            const randomSubdomain = subdomains[Math.floor(Math.random() * subdomains.length)];
            const finalUrl = urlTemplate.replace('{s}', randomSubdomain);

            const newLayer = new TileLayer(finalUrl, {
              minZoom: layerConfig.minZoom,
              maxZoom: layerConfig.maxZoom,
              attribution: layerConfig.attribution,
              background: layerConfig.background,
              supportsRetina: layerConfig.supportsRetina,
              maxCacheSize: layerConfig.maxCacheSize
            });

            this._map.setBaseLayer(newLayer);
          }
          return;
        } else if (e.key === "+" || e.key === "=") {
          this._map.stopAnimations();
          this._map.setZoom(this._map.getZoom() + 1);
          return;
        } else if (e.key === "-") {
          this._map.stopAnimations();
          this._map.setZoom(this._map.getZoom() - 1);
          return;
        }

        if (dx !== 0 || dy !== 0) {
          this._map.stopAnimations();
          const w = this._map.canvas.width / this._map.dpr;
          const h = this._map.canvas.height / this._map.dpr;
          this._map.center = this._map.screenToLatLon(w / 2 + dx, h / 2 + dy, this._map.getZoom(), this._map.getBearing());
          this._map.render();
        }
      }
    }

    // ============================================================
    // OVERLAY SYSTEM (MARKERS & POPUPS)
    // ============================================================

    class PopupManager {
      constructor(map) {
        this._map = map;
        this._openPopup = null;
        this._boundCloseOnEscape = this._closeOnEscape.bind(this);
        this._boundCloseOnClickOutside = this._closeOnClickOutside.bind(this);
        this._setupGlobalListeners();
      }

      _setupGlobalListeners() {
        document.addEventListener('keydown', this._boundCloseOnEscape);
        document.addEventListener('click', this._boundCloseOnClickOutside);
      }

      _teardownGlobalListeners() {
        document.removeEventListener('keydown', this._boundCloseOnEscape);
        document.removeEventListener('click', this._boundCloseOnClickOutside);
      }

      _closeOnEscape(e) {
        if (e.key === 'Escape' && this._openPopup) {
          this._openPopup.close();
        }
      }

      _closeOnClickOutside(e) {
        if (!this._openPopup) return;

        if (this._openPopup._popupElement && this._openPopup._popupElement.contains(e.target)) {
          return;
        }

        if (this._openPopup._anchor instanceof AtlasMarker &&
            this._openPopup._anchor._iconElement &&
            this._openPopup._anchor._iconElement.contains(e.target)) {
          return;
        }

        this._openPopup.close();
      }

      setOpenPopup(popup) {
        if (this._openPopup === popup) return;

        if (this._openPopup) {
          this._openPopup.close();
        }

        this._openPopup = popup;
      }

      getOpenPopup() {
        return this._openPopup;
      }

      clearOpenPopup(popup) {
        if (this._openPopup === popup) {
          this._openPopup = null;
        }
      }

      destroy() {
        this._teardownGlobalListeners();
        this._openPopup = null;
      }
    }

    class Overlay {
      constructor(options = {}) {
        this.options = options;
        this._map = null;
        this._events = {};
      }

      on(type, fn) {
        if (!this._events[type]) {
          this._events[type] = [];
        }
        this._events[type].push(fn);
        return this;
      }

      off(type, fn) {
        if (!this._events[type]) return this;
        if (!fn) {
          this._events[type] = [];
        } else {
          this._events[type] = this._events[type].filter(cb => cb !== fn);
        }
        return this;
      }

      fire(type, data = {}) {
        if (!this._events[type]) return;
        data.type = type;
        data.target = this;
        this._events[type].forEach(fn => fn(data));
      }

      addTo(map) {
        if (this._map) {
          this._map.removeOverlay(this);
        }
        this._map = map;
        map.addOverlay(this);
        return this;
      }

      remove() {
        if (this._map) {
          this._map.removeOverlay(this);
          this._map = null;
        }
        return this;
      }

      onAdd() {}
      onRemove() {}
      render() {}
    }

    /**
     * AtlasMarker - Interactive marker
     */
    class AtlasMarker extends Overlay {
      constructor(latlng, options = {}) {
        super(options);
        this._latlng = { ...latlng };
        this._iconElement = null;
        this._isHovered = false;
        this._isDragging = false;
        this._dragStart = null;
        this._popup = null;

        this.options = {
          draggable: false,
          riseOnHover: true,
          riseOffset: 250,
          zIndexOffset: 0,
          ...options
        };
      }

      onAdd() {
        this._iconElement = this._createIcon();
        this._map.container.appendChild(this._iconElement);

        this._iconElement.addEventListener('click', this._onClick.bind(this));
        this._iconElement.addEventListener('mouseenter', this._onMouseEnter.bind(this));
        this._iconElement.addEventListener('mouseleave', this._onMouseLeave.bind(this));

        if (this.options.draggable) {
          this._iconElement.addEventListener('mousedown', this._onMouseDown.bind(this));
          this._iconElement.addEventListener('touchstart', this._onTouchStart.bind(this), { passive: false });
        }

        this._updatePosition();
        this._updateZIndex();
      }

      onRemove() {
        if (this._popup) {
          this._popup.remove();
        }

        if (this._iconElement && this._iconElement.parentNode) {
          this._iconElement.parentNode.removeChild(this._iconElement);
        }

        this._iconElement = null;
        this._popup = null;
      }

      render() {
        if (this._iconElement) {
          this._updatePosition();
        }
      }

      _createIcon() {
        const el = document.createElement('div');
        el.className = 'atlas-marker';

        const shadow = document.createElement('div');
        shadow.className = 'atlas-marker-shadow';
        el.appendChild(shadow);

        const icon = document.createElement('div');
        icon.className = 'atlas-marker-icon';
        icon.innerHTML = this.options.html || `
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 36" width="24" height="36">
            <path d="M12 0C5.4 0 0 5.4 0 12c0 10.5 12 24 12 24s12-13.5 12-24C24 5.4 18.6 0 12 0zm0 16.5c-2.5 0-4.5-2-4.5-4.5S9.5 7.5 12 7.5s4.5 2 4.5 4.5-2 4.5-4.5 4.5z" fill="#ff7800" stroke="#fff" stroke-width="1.5"/>
          </svg>
        `;
        el.appendChild(icon);

        return el;
      }

      _updatePosition() {
        if (!this._iconElement || !this._map) return;
        const point = this._map.latLngToContainerPoint(this._latlng);
        this._iconElement.style.transform = `translate(${point.x}px, ${point.y}px) translate(-50%, -100%)`;
      }

      _updateZIndex() {
        if (!this._iconElement) return;

        let baseZIndex = 1000;
        if (this._isHovered && this.options.riseOnHover) {
          baseZIndex += this.options.riseOffset;
        }
        baseZIndex += this.options.zIndexOffset;

        this._iconElement.style.zIndex = baseZIndex;
      }

      _onClick(e) {
        e.stopPropagation();
        this.fire('click', { originalEvent: e });

        if (this._popup) {
          if (this._popup._isOpen) {
            this._popup.close();
          } else {
            this._popup.openOn(this);
          }
        }
      }

      _onMouseEnter(e) {
        if (!this._isDragging) {
          this._isHovered = true;
          this._updateZIndex();
          this._iconElement.classList.add('hover');
          this.fire('mouseover', { originalEvent: e });
        }
      }

      _onMouseLeave(e) {
        this._isHovered = false;
        this._updateZIndex();
        this._iconElement.classList.remove('hover');
        this.fire('mouseout', { originalEvent: e });
      }

      _onMouseDown(e) {
        if (e.button !== 0) return;
        e.stopPropagation();
        this._startDrag(e.clientX, e.clientY);
        document.addEventListener('mousemove', this._onMouseMove = this._onMouseMove.bind(this));
        document.addEventListener('mouseup', this._onMouseUp = this._onMouseUp.bind(this));
      }

      _onTouchStart(e) {
        if (e.touches.length !== 1) return;
        e.stopPropagation();
        e.preventDefault();
        this._startDrag(e.touches[0].clientX, e.touches[0].clientY);
        document.addEventListener('touchmove', this._onTouchMove = this._onTouchMove.bind(this), { passive: false });
        document.addEventListener('touchend', this._onTouchEnd = this._onTouchEnd.bind(this));
        document.addEventListener('touchcancel', this._onTouchEnd);
      }

      _startDrag(clientX, clientY) {
        this._isDragging = true;
        this._map.stopAnimations();
        this._map.isDragging = true;
        this._map.container.classList.add('dragging');

        this._dragStart = {
          x: clientX,
          y: clientY,
          latlng: { ...this._latlng }
        };

        this._iconElement.classList.add('dragging');
        this.fire('dragstart');
      }

      _onDragMove(clientX, clientY) {
        const startPoint = this._map.latLngToContainerPoint(this._dragStart.latlng);
        const dx = clientX - this._dragStart.x;
        const dy = clientY - this._dragStart.y;
        const newPoint = { x: startPoint.x + dx, y: startPoint.y + dy };
        const newLatLng = this._map.screenToLatLon(newPoint.x, newPoint.y);

        this._latlng = {
          lat: GISUtils.clampLatitude(newLatLng.lat),
          lon: GISUtils.wrapLongitude(newLatLng.lon)
        };

        this.fire('drag', { latlng: { ...this._latlng } });
        this.render();
      }

      _onMouseMove(e) {
        if (!this._isDragging) return;
        e.preventDefault();
        this._onDragMove(e.clientX, e.clientY);
      }

      _onTouchMove(e) {
        if (!this._isDragging || e.touches.length !== 1) return;
        e.preventDefault();
        this._onDragMove(e.touches[0].clientX, e.touches[0].clientY);
      }

      _onMouseUp() {
        this._endDrag();
      }

      _onTouchEnd() {
        this._endDrag();
      }

      _endDrag() {
        if (!this._isDragging) return;

        this._isDragging = false;
        this._map.isDragging = false;
        this._map.container.classList.remove('dragging');
        this._iconElement.classList.remove('dragging');

        document.removeEventListener('mousemove', this._onMouseMove);
        document.removeEventListener('mouseup', this._onMouseUp);
        document.removeEventListener('touchmove', this._onTouchMove);
        document.removeEventListener('touchend', this._onTouchEnd);
        document.removeEventListener('touchcancel', this._onTouchEnd);

        this.fire('dragend', { latlng: { ...this._latlng } });
      }

      setLatLng(latlng) {
        this._latlng = { ...latlng };
        if (this._map) {
          this._map.render();
        }
        return this;
      }

      getLatLng() {
        return { ...this._latlng };
      }

      bindPopup(content, options = {}) {
        if (this._popup) {
          this._popup.remove();
        }
        this._popup = new AtlasPopup(content, options);
        this._popup.addTo(this._map);
        return this;
      }

      unbindPopup() {
        if (this._popup) {
          this._popup.remove();
          this._popup = null;
        }
        return this;
      }

      togglePopup() {
        if (this._popup) {
          if (this._popup._isOpen) {
            this._popup.close();
          } else {
            this._popup.openOn(this);
          }
        }
        return this;
      }

      openPopup() {
        if (this._popup) {
          this._popup.openOn(this);
        }
        return this;
      }

      closePopup() {
        if (this._popup && this._popup._isOpen) {
          this._popup.close();
        }
        return this;
      }
    }

    /**
     * AtlasPopup - Popup for markers
     */
    class AtlasPopup extends Overlay {
      constructor(content, options = {}) {
        super(options);
        this._content = content;
        this._popupElement = null;
        this._isOpen = false;
        this._anchor = null;
        this._tipElement = null;

        this.options = {
          closeButton: true,
          autoClose: true,
          closeOnClick: true,
          className: '',
          maxWidth: 300,
          minWidth: 50,
          ...options
        };
      }

      onAdd() {
        this._popupElement = this._createPopupElement();
        this._map.container.appendChild(this._popupElement);

        if (this.options.closeButton) {
          const closeButton = this._popupElement.querySelector('.popup-close');
          if (closeButton) {
            closeButton.addEventListener('click', (e) => {
              e.stopPropagation();
              this.close();
            });
          }
        }

        if (!this._map._popupManager) {
          this._map._popupManager = new PopupManager(this._map);
        }
      }

      onRemove() {
        if (this._popupElement && this._popupElement.parentNode) {
          this._popupElement.parentNode.removeChild(this._popupElement);
        }
        this._popupElement = null;
        this._tipElement = null;
        this._isOpen = false;

        if (this._map && this._map._popupManager) {
          this._map._popupManager.clearOpenPopup(this);
        }
      }

      render() {
        if (!this._isOpen || !this._popupElement) return;
        this._updatePosition();
      }

      _createPopupElement() {
        const el = document.createElement('div');
        el.className = 'atlas-popup';

        if (this.options.className) {
          el.classList.add(this.options.className);
        }

        let closeButtonHtml = '';
        if (this.options.closeButton) {
          closeButtonHtml = `<button class="popup-close" aria-label="Close popup" title="Close">&times;</button>`;
        }

        el.innerHTML = `
          <div class="popup-content">${this._content}</div>
          ${closeButtonHtml}
          <div class="popup-tip"></div>
        `;

        this._tipElement = el.querySelector('.popup-tip');

        el.style.maxWidth = `${this.options.maxWidth}px`;
        el.style.minWidth = `${this.options.minWidth}px`;

        return el;
      }

      _updatePosition() {
        if (!this._anchor || !this._popupElement || !this._tipElement) return;

        let anchorPoint;
        if (this._anchor instanceof AtlasMarker && this._anchor._iconElement) {
          const rect = this._anchor._iconElement.getBoundingClientRect();
          const containerRect = this._map.container.getBoundingClientRect();
          anchorPoint = {
            x: rect.left - containerRect.left + rect.width / 2,
            y: rect.top - containerRect.top
          };
        } else if (this._anchor && typeof this._anchor.lat === 'number') {
          const point = this._map.latLngToContainerPoint(this._anchor);
          anchorPoint = { x: point.x, y: point.y };
        } else {
          return;
        }

        const popupRect = this._popupElement.getBoundingClientRect();
        const mapRect = this._map.container.getBoundingClientRect();

        const space = {
          top: anchorPoint.y,
          right: mapRect.width - anchorPoint.x,
          bottom: mapRect.height - anchorPoint.y,
          left: anchorPoint.x
        };

        let position = 'bottom';
        let tipClass = 'tip-bottom';

        if (space.bottom < popupRect.height && space.top >= popupRect.height) {
          position = 'top';
          tipClass = 'tip-top';
        } else if (space.right < popupRect.width / 2 && space.left >= popupRect.width / 2) {
          position = 'left';
          tipClass = 'tip-left';
        } else if (space.left < popupRect.width / 2 && space.right >= popupRect.width / 2) {
          position = 'right';
          tipClass = 'tip-right';
        }

        let left;
        let top;

        switch (position) {
          case 'top':
            left = anchorPoint.x - popupRect.width / 2;
            top = anchorPoint.y - popupRect.height;
            break;
          case 'bottom':
            left = anchorPoint.x - popupRect.width / 2;
            top = anchorPoint.y;
            break;
          case 'left':
            left = anchorPoint.x - popupRect.width;
            top = anchorPoint.y - popupRect.height / 2;
            break;
          case 'right':
            left = anchorPoint.x;
            top = anchorPoint.y - popupRect.height / 2;
            break;
        }

        left = Math.max(5, Math.min(mapRect.width - popupRect.width - 5, left));
        top = Math.max(5, Math.min(mapRect.height - popupRect.height - 5, top));

        this._popupElement.style.left = `${left}px`;
        this._popupElement.style.top = `${top}px`;
        this._popupElement.classList.add('open');

        this._tipElement.className = 'popup-tip ' + tipClass;
      }

      openOn(anchor) {
        this._anchor = anchor;
        this._isOpen = true;

        if (this._map && this._map._popupManager) {
          this._map._popupManager.setOpenPopup(this);
        }

        if (this._map) {
          this._map.render();
        }

        this.fire('open');
        return this;
      }

      close() {
        this._isOpen = false;

        if (this._popupElement) {
          this._popupElement.classList.remove('open');
        }

        if (this._map && this._map._popupManager) {
          this._map._popupManager.clearOpenPopup(this);
        }

        if (this._map) {
          this._map.render();
        }

        this.fire('close');
        return this;
      }

      setContent(content) {
        this._content = content;
        if (this._popupElement) {
          this._popupElement.querySelector('.popup-content').innerHTML = content;
        }
        return this;
      }
    }

    // ============================================================
    // FEATURE GROUPS & COLLECTIONS
    // ============================================================

    /**
     * FeatureGroup - Group multiple overlays
     */
    class FeatureGroup extends Overlay {
      constructor(layers = []) {
        super();
        this._layers = [];
        this._layerIds = {};

        for (const layer of layers) {
          this.addLayer(layer);
        }
      }

      addLayer(layer) {
        const id = layer._id = layer._id || `layer-${Math.random()}`;

        if (this._layerIds[id]) return this;

        this._layerIds[id] = true;
        this._layers.push(layer);

        if (this._map) {
          this._map.addOverlay(layer);
        }

        return this;
      }

      removeLayer(layer) {
        const id = layer._id;

        if (id && this._layerIds[id]) {
          delete this._layerIds[id];
          this._layers = this._layers.filter(l => l !== layer);

          if (this._map) {
            this._map.removeOverlay(layer);
          }
        }

        return this;
      }

      clearLayers() {
        for (const layer of [...this._layers]) {
          this.removeLayer(layer);
        }
        return this;
      }

      getLayers() {
        return [...this._layers];
      }

      eachLayer(fn) {
        for (const layer of this._layers) {
          fn(layer);
        }
        return this;
      }

      onAdd() {
        for (const layer of this._layers) {
          if (this._map) {
            this._map.addOverlay(layer);
          }
        }
        this.fire('add');
      }

      onRemove() {
        for (const layer of this._layers) {
          if (this._map) {
            this._map.removeOverlay(layer);
          }
        }
        this.fire('remove');
      }

      render() {
        for (const layer of this._layers) {
          if (layer.render) {
            layer.render();
          }
        }
      }
    }

    // ============================================================
    // SIMPLE SHAPES
    // ============================================================

    /**
     * Circle - Circle shape
     */
    class Circle extends Overlay {
      constructor(latlng, options = {}) {
        super(options);
        this._latlng = latlng;
        this.options = {
          radius: 100,
          color: '#3388ff',
          fillColor: '#3388ff',
          weight: 3,
          opacity: 1,
          fillOpacity: 0.2,
          ...options
        };
      }

      _calculateRadiusInPixels() {
        if (!this._map) return 0;

        const mPerPx = GISUtils.getResolution(this._map.center.lat, this._map.zoom);
        return this.options.radius / mPerPx;
      }

      render() {
        if (!this._map) return;

        const point = this._map.latLngToContainerPoint(this._latlng);
        const radiusPx = this._calculateRadiusInPixels();

        const { ctx } = this._map;
        ctx.beginPath();
        ctx.arc(point.x, point.y, radiusPx, 0, 2 * Math.PI);

        ctx.fillStyle = this.options.fillColor;
        ctx.globalAlpha = this.options.fillOpacity;
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.strokeStyle = this.options.color;
        ctx.lineWidth = this.options.weight;
        ctx.globalAlpha = this.options.opacity;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      setLatLng(latlng) {
        this._latlng = latlng;
        if (this._map) {
          this._map.render();
        }
        return this;
      }

      getLatLng() {
        return this._latlng;
      }
    }

    /**
     * Rectangle - Rectangle shape
     */
    class Rectangle extends Overlay {
      constructor(bounds, options = {}) {
        super(options);
        this._bounds = bounds;
        this.options = {
          color: '#3388ff',
          fillColor: '#3388ff',
          weight: 3,
          opacity: 1,
          fillOpacity: 0.2,
          ...options
        };
      }

      render() {
        if (!this._map) return;

        const nw = this._map.latLngToContainerPoint({
          lat: this._bounds[1][0],
          lon: this._bounds[0][1]
        });

        const se = this._map.latLngToContainerPoint({
          lat: this._bounds[0][0],
          lon: this._bounds[1][1]
        });

        const w = se.x - nw.x;
        const h = se.y - nw.y;

        const { ctx } = this._map;
        ctx.fillStyle = this.options.fillColor;
        ctx.globalAlpha = this.options.fillOpacity;
        ctx.fillRect(nw.x, nw.y, w, h);

        ctx.globalAlpha = 1;
        ctx.strokeStyle = this.options.color;
        ctx.lineWidth = this.options.weight;
        ctx.globalAlpha = this.options.opacity;
        ctx.strokeRect(nw.x, nw.y, w, h);
        ctx.globalAlpha = 1;
      }

      setBounds(bounds) {
        this._bounds = bounds;
        if (this._map) {
          this._map.render();
        }
        return this;
      }

      getBounds() {
        return this._bounds;
      }
    }

    /**
     * ImageOverlay - Geo-referenced image
     */
    class ImageOverlay extends Overlay {
      constructor(url, bounds, options = {}) {
        super(options);
        this._url = url;
        this._bounds = bounds;
        this._img = null;
        this.options = {
          opacity: 1,
          alt: '',
          interactive: false,
          ...options
        };
      }

      onAdd() {
        this._img = new Image();
        this._img.src = this._url;
        this._img.alt = this.options.alt;
        this._img.crossOrigin = "anonymous";
      }

      render() {
        if (!this._map || !this._img || !this._img.complete) return;

        const nw = this._map.latLngToContainerPoint({
          lat: this._bounds[1][0],
          lon: this._bounds[0][1]
        });

        const se = this._map.latLngToContainerPoint({
          lat: this._bounds[0][0],
          lon: this._bounds[1][1]
        });

        const w = se.x - nw.x;
        const h = se.y - nw.y;

        const { ctx } = this._map;
        ctx.globalAlpha = this.options.opacity;
        ctx.drawImage(this._img, nw.x, nw.y, w, h);
        ctx.globalAlpha = 1;
      }

      onRemove() {
        this._img = null;
      }

      setUrl(url) {
        this._url = url;
        this._img.src = url;
        if (this._map) {
          this._map.render();
        }
        return this;
      }

      setOpacity(opacity) {
        this.options.opacity = opacity;
        if (this._map) {
          this._map.render();
        }
        return this;
      }
    }

    /**
     * Polyline - Simple polyline
     */
    class Polyline extends Overlay {
      constructor(latlngs, options = {}) {
        super(options);
        this._latlngs = latlngs;
        this.options = {
          color: '#3388ff',
          weight: 3,
          opacity: 1,
          lineCap: 'round',
          lineJoin: 'round',
          ...options
        };
      }

      render() {
        if (!this._map || this._latlngs.length < 2) return;

        const points = this._latlngs.map(latlng => this._map.latLngToContainerPoint(latlng));

        const { ctx } = this._map;
        ctx.strokeStyle = this.options.color;
        ctx.lineWidth = this.options.weight;
        ctx.globalAlpha = this.options.opacity;
        ctx.lineCap = this.options.lineCap;
        ctx.lineJoin = this.options.lineJoin;

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }

        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      setLatLngs(latlngs) {
        this._latlngs = latlngs;
        if (this._map) {
          this._map.render();
        }
        return this;
      }

      getLatLngs() {
        return this._latlngs;
      }
    }

    /**
     * Polygon - Simple polygon
     */
    class Polygon extends Overlay {
      constructor(latlngs, options = {}) {
        super(options);
        this._latlngs = latlngs;
        this.options = {
          color: '#3388ff',
          fillColor: '#3388ff',
          weight: 3,
          opacity: 1,
          fillOpacity: 0.2,
          ...options
        };
      }

      render() {
        if (!this._map || this._latlngs.length < 3) return;

        const points = this._latlngs.map(latlng => this._map.latLngToContainerPoint(latlng));

        const { ctx } = this._map;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);

        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }

        ctx.closePath();

        ctx.fillStyle = this.options.fillColor;
        ctx.globalAlpha = this.options.fillOpacity;
        ctx.fill();

        ctx.globalAlpha = 1;
        ctx.strokeStyle = this.options.color;
        ctx.lineWidth = this.options.weight;
        ctx.globalAlpha = this.options.opacity;
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      setLatLngs(latlngs) {
        this._latlngs = latlngs;
        if (this._map) {
          this._map.render();
        }
        return this;
      }

      getLatLngs() {
        return this._latlngs;
      }
    }

    // ============================================================
    // NOTIFICATION SYSTEM
    // ============================================================

    class NotificationControl {
      constructor(map) {
        this._map = map;
        this._container = map.container.querySelector('.atlas-notification-container');

        if (!this._container) {
          this._container = document.createElement('div');
          this._container.className = 'atlas-notification-container';
          this._map.container.appendChild(this._container);
        }
      }

      show(message, duration = 5000) {
        const notification = document.createElement('div');
        notification.className = 'atlas-notification';
        notification.textContent = message;

        this._container.appendChild(notification);

        setTimeout(() => {
          notification.remove();
        }, duration);
      }
    }

    // ============================================================
    // PERFORMANCE MONITORING
    // ============================================================

    class PerformanceMonitor {
      constructor(map) {
        this._map = map;
        this._frameCount = 0;
        this._lastTime = performance.now();
        this._fps = 0;
        this._stats = {
          fps: 0,
          tiles: 0,
          overlays: 0,
          memory: 0
        };

        this._displayStats = false;
        this._statsElement = null;
      }

      toggleStats() {
        this._displayStats = !this._displayStats;

        if (this._displayStats) {
          this._createStatsDisplay();
          this._updateStats();
        } else if (this._statsElement) {
          this._statsElement.remove();
          this._statsElement = null;
        }
      }

      _createStatsDisplay() {
        if (this._statsElement) return;

        this._statsElement = document.createElement('div');
        this._statsElement.className = 'performance-stats';
        this._map.container.appendChild(this._statsElement);
      }

      _updateStats() {
        if (!this._displayStats) return;

        const now = performance.now();
        this._frameCount++;

        if (now - this._lastTime >= 1000) {
          this._fps = this._frameCount;
          this._frameCount = 0;
          this._lastTime = now;

          this._stats.fps = this._fps;
          this._stats.tiles = this._map._baseLayer ? this._map._baseLayer.tileCache.size : 0;
          this._stats.overlays = this._map._overlays.length;

          if (performance.memory) {
            this._stats.memory = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
          }

          if (this._statsElement) {
            this._statsElement.innerHTML = `
              FPS: ${this._stats.fps}<br>
              Tiles: ${this._stats.tiles}<br>
              Overlays: ${this._stats.overlays}<br>
              Memory: ${this._stats.memory} MB
            `;
          }
        }

        requestAnimationFrame(() => this._updateStats());
      }
    }

    // ============================================================
    // MAIN ATLAS CLASS
    // ============================================================

    /**
     * Atlas - Complete mapping library
     */
    class Atlas {
      constructor(id, options = {}) {
        this.container = document.getElementById("map-container");
        if (!this.container) {
          throw new Error('[Atlas] The required "map-container" element was not found in the DOM.');
        }

        this.canvas = document.getElementById(id);
        if (!this.canvas) {
          throw new Error(`[Atlas] The required canvas element with id "${id}" was not found in the DOM.`);
        }

        this.ctx = this.canvas.getContext("2d");

        Object.assign(CONFIG, options);

        this.center = {
          lon: GISUtils.wrapLongitude(CONFIG.defaultCenter.lon),
          lat: GISUtils.clampLatitude(CONFIG.defaultCenter.lat)
        };

        this.zoom = CONFIG.defaultZoom;
        this.bearing = 0;
        this.renderScheduled = false;
        this.zoomOverlay = document.getElementById("zoom-overlay");
        this.loadingEl = document.getElementById("loading");
        this.loadingCountEl = document.getElementById("loading-count");
        this.coordsEl = document.getElementById("coords");
        this._inertiaRAF = null;
        this._eventListeners = {};
        this._layers = [];
        this._baseLayer = null;
        this._events = {};
        this._controls = [];
        this._controlCorners = {};
        this._overlays = [];
        this._handlers = {};
        this._popupManager = null;
        this.projection = DEFAULT_PROJECTION;

        // New features
        this._drawingManager = null;
        this._measurementTool = null;
        this._markerCluster = null;
        this._performanceMonitor = null;

        this.addHandler('dragPan', DragPanHandler);
        this.addHandler('scrollZoom', ScrollZoomHandler);
        this.addHandler('doubleClickZoom', DoubleClickZoomHandler);
        this.addHandler('touchZoomRotate', TouchZoomRotateHandler);
        this.addHandler('keyboardPan', KeyboardPanHandler);

        this.notifications = new NotificationControl(this);
        this._performanceMonitor = new PerformanceMonitor(this);

        console.warn(
          `%c[Atlas] You are using map tiles.
%cPlease comply with the respective tile usage policies.
%c- OpenStreetMap: https://operations.osmfoundation.org/policies/tiles/
%c- Esri: https://www.esri.com/en-us/legal/terms/full-master-agreement`,
          "font-weight:bold;color:#e74c3c;",
          "color:#3498db;",
          "color:#2ecc71;",
          "color:#f39c12;"
        );

        this.resize();
        this.addControl(new ZoomControl({ position: 'top-left' }));
        this.addControl(new LayerControl({ position: 'top-left' }));
        this.addControl(new FullscreenControl({ position: 'top-right' }));
        this.addControl(new ScaleControl({ position: 'bottom-right' }));
        this.addControl(new AttributionControl({ position: 'bottom-left' }));
        this.addControl(new CompassControl({ position: 'top-left' }));
        this.addControl(new ResetZoomControl({ position: 'top-left' }));

        this.updateAttribution();
        this.render();
        this.fire('load');
      }

      // ========== EVENT SYSTEM ==========

      on(type, fn) {
        if (!this._events[type]) {
          this._events[type] = [];
        }
        this._events[type].push(fn);
        return this;
      }

      off(type, fn) {
        if (!this._events[type]) return this;
        if (!fn) {
          this._events[type] = [];
        } else {
          this._events[type] = this._events[type].filter(cb => cb !== fn);
        }
        return this;
      }

      fire(type, data = {}) {
        if (!this._events[type]) return;
        data.type = type;
        data.target = this;
        this._events[type].forEach(fn => fn(data));
      }

      // ========== LAYER MANAGEMENT ==========

      addLayer(layer) {
        if (!(layer instanceof Layer)) {
          throw new Error('Argument must be an instance of Layer');
        }

        if (!this._layers.includes(layer)) {
          this._layers.push(layer);
          layer._map = this;
          layer.onAdd();
          this.render();

          if (!this._baseLayer || (layer instanceof TileLayer && !this._baseLayer)) {
            this._baseLayer = layer;
            this.container.style.background = layer.getBackground();
          }
        }

        return this;
      }

      removeLayer(layer) {
        const index = this._layers.indexOf(layer);
        if (index !== -1) {
          this._layers.splice(index, 1);
          layer.onRemove();
          layer._map = null;

          if (this._baseLayer === layer) {
            this._baseLayer = this._layers.find(l => l instanceof TileLayer) || null;
            if (this._baseLayer) {
              this.container.style.background = this._baseLayer.getBackground();
            }
          }

          this.render();
        }

        return this;
      }

      setBaseLayer(newLayer) {
        if (!(newLayer instanceof TileLayer)) {
          throw new Error('Argument must be an instance of TileLayer');
        }

        if (this._baseLayer && this._baseLayer !== newLayer) {
          this.removeLayer(this._baseLayer);
        }

        if (!this._layers.includes(newLayer)) {
          this.addLayer(newLayer);
        } else {
          this._baseLayer = newLayer;
          this.container.style.background = newLayer.getBackground();
          this.zoom = Math.max(newLayer.getMinZoom(), Math.min(newLayer.getMaxZoom(), this.zoom));
          this.render();
        }

        return this;
      }

      getBaseLayer() {
        return this._baseLayer;
      }

      // ========== CONTROL MANAGEMENT ==========

      addControl(control) {
        if (!(control instanceof Control)) {
          throw new Error('Argument must be an instance of Control');
        }
        this._controls.push(control);
        control.addTo(this);
        return this;
      }

      removeControl(control) {
        const index = this._controls.indexOf(control);
        if (index !== -1) {
          this._controls.splice(index, 1);
          control.remove();
        }
        return this;
      }

      getControls() {
        return [...this._controls];
      }

      // ========== HANDLER MANAGEMENT ==========

      addHandler(name, HandlerClass) {
        if (this._handlers[name]) {
          console.warn(`Handler '${name}' already exists.`);
          return this;
        }

        this._handlers[name] = new HandlerClass(this);
        this._handlers[name].enable();
        return this;
      }

      removeHandler(name) {
        if (!this._handlers[name]) return this;
        this._handlers[name].destroy();
        delete this._handlers[name];
        return this;
      }

      getHandler(name) {
        return this._handlers[name] || null;
      }

      enableHandler(name) {
        const handler = this.getHandler(name);
        if (handler) handler.enable();
        return this;
      }

      disableHandler(name) {
        const handler = this.getHandler(name);
        if (handler) handler.disable();
        return this;
      }

      getHandlers() {
        return { ...this._handlers };
      }

      // ========== OVERLAY MANAGEMENT ==========

      addOverlay(overlay) {
        if (!(overlay instanceof Overlay)) {
          throw new Error('Argument must be an instance of Overlay');
        }

        if (!this._overlays.includes(overlay)) {
          this._overlays.push(overlay);
          overlay._map = this;
          overlay.onAdd();
          this.render();
        }

        return this;
      }

      removeOverlay(overlay) {
        const index = this._overlays.indexOf(overlay);
        if (index !== -1) {
          this._overlays.splice(index, 1);
          overlay.onRemove();
          overlay._map = null;
          this.render();
        }

        return this;
      }

      getOverlays() {
        return [...this._overlays];
      }

      // ========== CORE MAP METHODS ==========

      setZoom(z) {
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const nz = Math.max(minZoom, Math.min(maxZoom, z));

        if (nz === this.zoom) return;

        this.zoom = nz;
        this.render();
        this.showZoomOverlay();
        this.updateControlsUI();
        this.fire('zoom');
      }

      setBearing(rad) {
        const nr = normalizeAngle(rad);
        if (Math.abs(nr - this.bearing) < 1e-6) return;

        this.bearing = nr;
        this.render();
        this.fire('rotate');
      }

      showZoomOverlay() {
        const overlay = this.zoomOverlay;
        overlay.textContent = `Zoom: ${this.zoom.toFixed(2)}`;
        overlay.style.opacity = 1;

        clearTimeout(this._zTimer);
        this._zTimer = setTimeout(() => overlay.style.opacity = 0, 500);
      }

      stopInertia() {
        if (this._inertiaRAF) cancelAnimationFrame(this._inertiaRAF);
        this._inertiaRAF = null;
      }

      stopAnimations() {
        this.stopInertia();

        if (this._zoomAnim?.raf) cancelAnimationFrame(this._zoomAnim.raf);
        this._zoomAnim = null;

        if (this._flyAnim?.raf) cancelAnimationFrame(this._flyAnim.raf);
        this._flyAnim = null;

        if (this._panAnim?.raf) cancelAnimationFrame(this._panAnim.raf);
        this._panAnim = null;
      }

      resize() {
        const w = this.container.offsetWidth;
        const h = this.container.offsetHeight;
        this.dpr = window.devicePixelRatio || 1;

        this.canvas.width = w * this.dpr;
        this.canvas.height = h * this.dpr;
        this.canvas.style.width = w + "px";
        this.canvas.style.height = h + "px";
        this.ctx.setTransform(this.dpr, 0, 0, this.dpr, 0, 0);

        this.render();
        this.fire('resize');
      }

      scheduleRender() {
        if (this.renderScheduled) return;
        this.renderScheduled = true;
        requestAnimationFrame(() => {
          this.renderScheduled = false;
          this._draw();
        });
      }

      render() {
        this.scheduleRender();
      }

      _snapCanvasToPixelGrid() {
        const currentTransform = this.ctx.getTransform();
        const physicalTranslateX = currentTransform.e * this.dpr;
        const physicalTranslateY = currentTransform.f * this.dpr;
        const snapX = -(physicalTranslateX % 1) / this.dpr;
        const snapY = -(physicalTranslateY % 1) / this.dpr;
        this.ctx.translate(snapX, snapY);
      }

      _draw() {
        const backgroundColor = this._baseLayer ? this._baseLayer.getBackground() : '#000';
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;

        this.ctx.fillStyle = backgroundColor;
        this.ctx.fillRect(0, 0, w, h);

        for (const layer of this._layers) {
          layer.render();
        }

        for (const overlay of this._overlays) {
          overlay.render();
        }

        // Render drawing shapes
        if (this._drawingManager) {
          this._drawingManager.renderShapes(this.ctx);
        }

        // Render measurement
        if (this._measurementTool && this._measurementTool.isActive) {
          this._measurementTool.render(this.ctx);
        }

        // Render marker clusters
        if (this._markerCluster) {
          this._markerCluster.render(this.ctx);
        }

        this._snapCanvasToPixelGrid();

        let loadingCount = 0;
        if (this._baseLayer && this._baseLayer instanceof TileLayer) {
          loadingCount = this._baseLayer.loadingTiles.size;
        }

        this.loadingEl.classList.toggle("visible", loadingCount > 0);
        this.loadingCountEl.textContent = loadingCount;
        this.coordsEl.textContent =
          `${this.center.lat.toFixed(6)}°, ${this.center.lon.toFixed(6)}° | Z: ${this.zoom.toFixed(2)} | Bearing: ${(this.bearing * CONSTANTS.RAD2DEG).toFixed(1)}° | Layer: ${this._baseLayer ? 'Custom' : 'None'}`;

        this.updateControlsUI();
        this.fire('moveend');
      }

      updateAttribution() {
        for (const control of this._controls) {
          if (control instanceof AttributionControl && typeof control._update === 'function') {
            control._update();
          }
        }
      }

      updateControlsUI() {
        for (const control of this._controls) {
          if (typeof control._update === 'function') {
            control._update();
          }
        }
      }

      getCenter() {
        return { ...this.center };
      }

      getZoom() {
        return this.zoom;
      }

      getBearing() {
        return this.bearing;
      }

      // Coordinate conversion
      screenToLatLon(ax, ay, zoom = this.zoom, bearing = this.bearing, center = this.center) {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(zoom);
        const ts = CONSTANTS.TILE_SIZE * Math.pow(2, zoom - zInt);
        const ct = this.projection.latLngToTile(center, zInt);

        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };
        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -bearing);
        const tpt = { x: ct.x + v.x, y: ct.y + v.y };
        const ll = this.projection.tileToLatLng(tpt.x, tpt.y, zInt);

        return {
          lon: GISUtils.wrapLongitude(ll.lon),
          lat: GISUtils.clampLatitude(ll.lat)
        };
      }

      containerPointToLatLng(point) {
        return this.screenToLatLon(point.x, point.y);
      }

      lonLatToTile(lon, lat, z) {
        return this.projection.latLngToTile({ lat, lon }, z);
      }

      latLngToContainerPoint(latlng) {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const zInt = Math.floor(this.zoom);
        const ts = CONSTANTS.TILE_SIZE * Math.pow(2, this.zoom - zInt);
        const ct = this.projection.latLngToTile(this.center, zInt);
        const pt = this.projection.latLngToTile(latlng, zInt);

        const trX = (pt.x - ct.x) * ts;
        const trY = (pt.y - ct.y) * ts;
        const anchorVec = rot(trX, trY, this.bearing);

        const screenX = w / 2 + anchorVec.x;
        const screenY = h / 2 + anchorVec.y;

        return { x: screenX, y: screenY };
      }

      /**
       * Fit bounds
       */
      fitBounds(bounds, options = {}) {
        const { padding = 50, duration = CONSTANTS.FLYTO_DURATION, maxZoom } = options;

        const minLat = Math.min(bounds[0][0], bounds[1][0]);
        const maxLat = Math.max(bounds[0][0], bounds[1][0]);
        const minLon = Math.min(bounds[0][1], bounds[1][1]);
        const maxLon = Math.max(bounds[0][1], bounds[1][1]);

        const centerLat = (minLat + maxLat) / 2;
        const centerLon = (minLon + maxLon) / 2;

        const w = this.canvas.width / this.dpr - 2 * padding;
        const h = this.canvas.height / this.dpr - 2 * padding;

        const topLeftTile = this.projection.latLngToTile({ lat: maxLat, lon: minLon }, 28);
        const bottomRightTile = this.projection.latLngToTile({ lat: minLat, lon: maxLon }, 28);

        const latDist = bottomRightTile.y - topLeftTile.y;
        const lonDist = bottomRightTile.x - topLeftTile.x;

        const zoom = Math.max(0,
          Math.floor(
            Math.log2(
              Math.min(w / lonDist, h / latDist) * CONSTANTS.TILE_SIZE
            )
          )
        );

        const finalZoom = maxZoom ? Math.min(zoom, maxZoom) : zoom;

        this.flyTo({
          center: { lat: centerLat, lon: centerLon },
          zoom: finalZoom,
          duration,
          bearing: this.bearing
        });

        return this;
      }

      /**
       * Get visible bounds
       */
      getBounds() {
        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;

        const nw = this.screenToLatLon(0, 0);
        const se = this.screenToLatLon(w, h);

        return {
          getNorthWest: () => nw,
          getSouthEast: () => se,
          getNorth: () => nw.lat,
          getSouth: () => se.lat,
          getWest: () => nw.lon,
          getEast: () => se.lon,
          contains: (latlng) => {
            return latlng.lat >= se.lat && latlng.lat <= nw.lat &&
                   latlng.lon >= nw.lon && latlng.lon <= se.lon;
          }
        };
      }

      /**
       * Pan to location
       */
      panTo(latlng, options = {}) {
        const { duration = 250, easing = EASING.easeInOutCubic } = options;

        this.stopAnimations();
        const startT = performance.now();
        const startCenter = { ...this.center };
        const endCenter = {
          lat: GISUtils.clampLatitude(latlng.lat),
          lon: GISUtils.wrapLongitude(latlng.lon)
        };

        const dLat = endCenter.lat - startCenter.lat;
        const dLon = wrapDeltaLon(endCenter.lon - startCenter.lon);

        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));

          this.center = {
            lat: startCenter.lat + dLat * p,
            lon: startCenter.lon + dLon * p
          };

          this.render();

          if (t < 1) {
            this._panAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._panAnim = null;
            this.fire('moveend');
          }
        };

        this._panAnim = { raf: requestAnimationFrame(step) };
        this.fire('movestart');

        return this;
      }

      applyZoomRotateAbout(ax, ay, newZoom, newBearing, anchorLL = null) {
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        newZoom = Math.max(minZoom, Math.min(maxZoom, newZoom));

        const w = this.canvas.width / this.dpr;
        const h = this.canvas.height / this.dpr;
        const anchorVec = { x: ax - w / 2, y: ay - h / 2 };

        const currAnchorLL = anchorLL || this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);

        const zInt = Math.floor(newZoom);
        const ts = CONSTANTS.TILE_SIZE * Math.pow(2, newZoom - zInt);
        const Ptile = this.projection.latLngToTile(currAnchorLL, zInt);

        const v = rot(anchorVec.x / ts, anchorVec.y / ts, -newBearing);
        const ctNew = { x: Ptile.x - v.x, y: Ptile.y - v.y };
        const newCenter = this.projection.tileToLatLng(ctNew.x, ctNew.y, zInt);

        this.center = {
          lon: GISUtils.wrapLongitude(newCenter.lon),
          lat: GISUtils.clampLatitude(newCenter.lat)
        };
        this.zoom = newZoom;
        this.bearing = normalizeAngle(newBearing);
      }

      showZoomIndicator(x, y) {
        if (this._zoomIndicator) {
          this.container.removeChild(this._zoomIndicator);
        }

        const indicator = document.createElement("div");
        indicator.style.position = "absolute";
        indicator.style.left = (x - 15) + "px";
        indicator.style.top = (y - 15) + "px";
        indicator.style.width = "30px";
        indicator.style.height = "30px";
        indicator.style.borderRadius = "50%";
        indicator.style.border = "2px solid #333";
        indicator.style.opacity = "0.8";
        indicator.style.pointerEvents = "none";
        indicator.style.zIndex = "100";
        indicator.style.animation = "zoom-indicator 0.6s ease-out forwards";

        this.container.appendChild(indicator);
        this._zoomIndicator = indicator;

        setTimeout(() => {
          if (this._zoomIndicator && this._zoomIndicator.parentNode) {
            this.container.removeChild(this._zoomIndicator);
            this._zoomIndicator = null;
          }
        }, 600);
      }

      animateZoomRotateAbout(ax, ay, toZoom, toBearing = this.bearing, duration = CONSTANTS.WHEEL_ZOOM_DURATION, easing = EASING.easeInOutCubic) {
        this.showZoomIndicator(ax, ay);
        this.stopAnimations();

        const startT = performance.now();
        const sZoom = this.zoom;
        const sBear = this.bearing;
        const deltaBear = shortestAngleDiff(sBear, toBearing);
        const anchorLL = this.screenToLatLon(ax, ay, this.zoom, this.bearing, this.center);

        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));

          const z = sZoom + (toZoom - sZoom) * p;
          const b = sBear + deltaBear * p;

          this.applyZoomRotateAbout(ax, ay, z, b, anchorLL);
          this.render();

          if (t < 1) {
            this._zoomAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._zoomAnim = null;
            this.updateControlsUI();
            this.fire('zoomend');
          }
        };

        this._zoomAnim = { raf: requestAnimationFrame(step) };
        this.fire('zoomstart');
      }

      smoothZoomAt(ax, ay, deltaZ) {
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const target = Math.max(minZoom, Math.min(maxZoom, this.zoom + deltaZ));

        this.animateZoomRotateAbout(
          ax,
          ay,
          target,
          this.bearing,
          CONSTANTS.WHEEL_ZOOM_DURATION,
          EASING.easeInOutCubic
        );
      }

      flyTo({ center = this.center, zoom = this.zoom, bearing = this.bearing, duration = CONSTANTS.FLYTO_DURATION, easing = EASING.easeInOutCubic } = {}) {
        const minZoom = this._baseLayer ? this._baseLayer.getMinZoom() : 0;
        const maxZoom = this._baseLayer ? this._baseLayer.getMaxZoom() : 18;
        const targetZoom = Math.max(minZoom, Math.min(maxZoom, zoom));

        this.stopAnimations();

        const startT = performance.now();
        const sC = { ...this.center };
        const eC = { lon: GISUtils.wrapLongitude(center.lon), lat: center.lat };
        const dLon = wrapDeltaLon(eC.lon - sC.lon);
        const dLat = eC.lat - sC.lat;
        const sZ = this.zoom;
        const eZ = targetZoom;
        const sB = this.bearing;
        const dB = shortestAngleDiff(sB, bearing);

        const step = () => {
          const t = (performance.now() - startT) / Math.max(1, duration);
          const p = t >= 1 ? 1 : easing(Math.max(0, Math.min(1, t)));

          const currentLon = sC.lon + dLon * p;

          this.center = {
            lon: t >= 1 ? GISUtils.wrapLongitude(currentLon) : currentLon,
            lat: GISUtils.clampLatitude(sC.lat + dLat * p)
          };

          this.zoom = sZ + (eZ - sZ) * p;
          this.bearing = normalizeAngle(sB + dB * p);
          this.render();

          if (t < 1) {
            this._flyAnim = { raf: requestAnimationFrame(step) };
          } else {
            this._flyAnim = null;
            this.updateControlsUI();
            this.fire('moveend');
          }
        };

        this._flyAnim = { raf: requestAnimationFrame(step) };
        this.fire('movestart');
      }

      // ========== NEW: DRAWING & MEASUREMENT ==========

      /**
       * Initialize drawing manager
       */
      initDrawingManager(options = {}) {
        if (!this._drawingManager) {
          this._drawingManager = new DrawingManager(this, options);
          const drawingControl = new DrawingControl({ position: 'top-left' });
          drawingControl.setDrawingManager(this._drawingManager);
          this.addControl(drawingControl);
        }
        return this._drawingManager;
      }

      /**
       * Initialize measurement tool
       */
      initMeasurementTool() {
        if (!this._measurementTool) {
          this._measurementTool = new MeasurementTool(this);
          const measurementControl = new MeasurementControl({ position: 'top-left' });
          measurementControl.setMeasurementTool(this._measurementTool);
          this.addControl(measurementControl);
        }
        return this._measurementTool;
      }

      /**
       * Initialize marker clustering
       */
      initMarkerClustering(options = {}) {
        if (!this._markerCluster) {
          this._markerCluster = new MarkerCluster(options);
          this._markerCluster.addTo(this);
        }
        return this._markerCluster;
      }

      /**
       * Add clustered marker
       */
      addClusteredMarker(latlng, options = {}) {
        const marker = new AtlasMarker(latlng, options);
        marker.addTo(this);

        if (this._markerCluster) {
          this._markerCluster.addMarker(marker);
          this._markerCluster.cluster();
        }

        return marker;
      }

      /**
       * Toggle performance stats
       */
      togglePerformanceStats() {
        if (this._performanceMonitor) {
          this._performanceMonitor.toggleStats();
        }
        return this;
      }

      // ========== LIFECYCLE ==========

      destroy() {
        this.stopAnimations();

        for (const layer of [...this._layers]) {
          this.removeLayer(layer);
        }

        for (const control of [...this._controls]) {
          this.removeControl(control);
        }

        for (const corner in this._controlCorners) {
          const container = this._controlCorners[corner];
          if (container && container.parentNode) {
            container.parentNode.removeChild(container);
          }
        }
        this._controlCorners = {};

        for (const name in this._handlers) {
          this.removeHandler(name);
        }

        for (const overlay of [...this._overlays]) {
          this.removeOverlay(overlay);
        }

        if (this._popupManager) {
          this._popupManager.destroy();
          this._popupManager = null;
        }

        this.fire('unload');
        this._events = {};

        console.log("[Atlas] Instance destroyed.");
      }
    }

    // ============================================================
    // GLOBAL EXPORTS & INITIALIZATION
    // ============================================================

    // Export classes to window
    window.Atlas = Atlas;
    window.TileLayer = TileLayer;
    window.GeoJSONLayer = GeoJSONLayer;
    window.HeatmapLayer = HeatmapLayer;
    window.Layer = Layer;
    window.AtlasMarker = AtlasMarker;
    window.AtlasPopup = AtlasPopup;
    window.FeatureGroup = FeatureGroup;
    window.Circle = Circle;
    window.Rectangle = Rectangle;
    window.ImageOverlay = ImageOverlay;
    window.Polyline = Polyline;
    window.Polygon = Polygon;
    window.DrawingManager = DrawingManager;
    window.MeasurementTool = MeasurementTool;
    window.MarkerCluster = MarkerCluster;
    window.GISUtils = GISUtils;

    /**
     * Initialize map with geolocation
     */
    function handleGeolocationError(message) {
      console.warn(message);

      if (!window.atlasInstance) {
        window.atlasInstance = new Atlas("map");
      }

      window.atlasInstance.notifications.show("Could not determine location. Showing default map.");

      const subdomains = ['a', 'b', 'c'];
      const randomSubdomain = subdomains[Math.floor(Math.random() * subdomains.length)];
      const osmLayer = new TileLayer(
        `https://${randomSubdomain}.tile.openstreetmap.org/{z}/{x}/{y}.png`,
        {
          minZoom: 0,
          maxZoom: 19,
          attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
          background: "#e6e6e6",
          supportsRetina: true,
          maxCacheSize: 500
        }
      );

      window.atlasInstance.setBaseLayer(osmLayer);
    }

    function initializeAtlas() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => {
          window.atlasInstance = new Atlas("map");

          const lat = pos.coords.latitude;
          const lon = pos.coords.longitude;

          window.atlasInstance.flyTo({ center: { lat, lon }, zoom: 10 });

          const subdomains = ['a', 'b', 'c'];
          const randomSubdomain = subdomains[Math.floor(Math.random() * subdomains.length)];
          const osmLayer = new TileLayer(
            `https://${randomSubdomain}.tile.openstreetmap.org/{z}/{x}/{y}.png`,
            {
              minZoom: 0,
              maxZoom: 19,
              attribution: '© <a href="https://www.openstreetmap.org/copyright" target="_blank" rel="noopener noreferrer">OpenStreetMap contributors</a>',
              background: "#e6e6e6",
              supportsRetina: true,
              maxCacheSize: 500
            }
          );

          window.atlasInstance.setBaseLayer(osmLayer);

          // Create user marker
          const userMarker = new AtlasMarker({ lat, lon }, { draggable: true });

          userMarker.bindPopup(`
            <h3 style="margin:0 0 8px 0; font-size:16px;">You Are Here</h3>
            <p style="margin:0; font-size:14px;">Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}</p>
            <p style="margin:8px 0 0 0; font-size:12px; color:#666;">Drag me around!</p>
          `);

          userMarker.on('dragend', (e) => {
            const { lat, lon } = e.latlng;
            userMarker._popup.setContent(`
              <h3 style="margin:0 0 8px 0; font-size:16px;">You Are Here</h3>
              <p style="margin:0; font-size:14px;">Lat: ${lat.toFixed(6)}<br>Lon: ${lon.toFixed(6)}</p>
              <p style="margin:8px 0 0 0; font-size:12px; color:#666;">Drag me around!</p>
            `);
          });

          userMarker.addTo(window.atlasInstance);

          // Add GeoJSON layer
          const geojsonLayer = new GeoJSONLayer({
            type: 'FeatureCollection',
            features: [
              {
                type: 'Feature',
                geometry: {
                  type: 'Point',
                  coordinates: [lon, lat]
                },
                properties: {
                  name: 'You Are Here (GeoJSON)'
                }
              }
            ]
          }, {
            style: { radius: 8, fillColor: '#ff7800', color: '#fff', weight: 2 },
            interactive: true
          });

          geojsonLayer.on('click', (e) => {
            alert(`Clicked on GeoJSON point: ${e.feature.properties.name}`);
          });

          window.atlasInstance.addLayer(geojsonLayer);

        }, (error) => {
          handleGeolocationError(`[Atlas] Geolocation failed: ${error.message}. Loading map with default view.`);
        }, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 });
      } else {
        handleGeolocationError("[Atlas] Geolocation is not supported by this browser. Loading map with default view.");
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeAtlas);
    } else {
      initializeAtlas();
    }

  </script>
</body>
</html>
