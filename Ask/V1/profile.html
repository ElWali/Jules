<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Site Profile</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        body { font-family: sans-serif; }
        #map { height: 300px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1 id="site-name"></h1>
    <div id="map"></div>
    <h2>Summary</h2>
    <p id="summary"></p>
    <h2>Radiocarbon Dates</h2>
    <table id="dates-table">
        <thead>
            <tr>
                <th>Lab Code</th>
                <th>BP</th>
                <th>Std</th>
                <th>Material</th>
                <th>Cultural Periods</th>
                <th>Typochronological Units</th>
                <th>References</th>
            </tr>
        </thead>
        <tbody>
        </tbody>
    </table>
    <h2>Date Distribution</h2>
    <canvas id="date-chart" width="400" height="200"></canvas>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Get site name from URL
            const urlParams = new URLSearchParams(window.location.search);
            const siteName = urlParams.get('site');

            if (siteName) {
                const decodedSiteName = decodeURIComponent(siteName);
                document.getElementById('site-name').textContent = decodedSiteName;
                fetch('output.json')
                    .then(response => response.json())
                    .then(data => {
                        const siteData = data.filter(item => item.site === decodedSiteName);
                        if (siteData.length > 0) {
                            // For now, just use the first entry for lat/lon
                            const { lat, lng } = siteData[0];
                            const map = L.map('map').setView([lat, lng], 10);
                            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                            }).addTo(map);
                            L.marker([lat, lng]).addTo(map);

                            // Field label mapping
                            const fieldLabels = {
                                d: 'Sample ID',
                                labnr: 'Laboratory Number',
                                bp: 'Radiocarbon Age (BP)',
                                std: 'Uncertainty',
                                'delta c13': 'δ¹³C (delta C13)',
                                'feature type': 'Feature Type',
                                site: 'Site Name',
                                country: 'Country',
                                lat: 'Latitude',
                                lng: 'Longitude',
                                'site type': 'Site Type',
                                periods: 'Cultural Period(s)',
                                'typochronological units': 'Typochronological Unit(s)',
                                'ecochronological units': 'Ecochronological Unit(s)',
                                reference: 'Reference'
                            };

                            // Populate the table and summary
                            const tableBody = document.querySelector('#dates-table tbody');
                            let summaryHtml = '';
                            let processedSummary = false;

                            siteData.forEach(item => {
                                // Add to table
                                const row = tableBody.insertRow();
                                row.insertCell(0).textContent = item.lab_code || 'N/A';
                                row.insertCell(1).textContent = item.bp;
                                row.insertCell(2).textContent = item.std;
                                row.insertCell(3).textContent = item.material;
                                row.insertCell(4).textContent = item.periods ? JSON.parse(item.periods).map(p => p.periode).join(', ') : 'N/A';
                                row.insertCell(5).textContent = item['typochronological units'] ? JSON.parse(item['typochronological units']).map(t => t.typochronological_unit).join(', ') : 'N/A';
                                row.insertCell(6).textContent = item.reference ? JSON.parse(item.reference).map(r => r.reference).join(', ') : 'N/A';

                                // Process for summary view - only needs to be done once
                                if (!processedSummary) {
                                    const summaryFields = ['site type', 'country', 'feature type', 'periods', 'typochronological units', 'ecochronological units', 'reference'];
                                    summaryFields.forEach(key => {
                                        if (item[key]) {
                                            let value = item[key];
                                            if (typeof value === 'string' && (value.startsWith('[') || value.startsWith('{'))) {
                                                try {
                                                    const parsed = JSON.parse(value);
                                                    if (Array.isArray(parsed)) {
                                                        const cleaned = parsed
                                                            .map(obj => {
                                                                if (obj && typeof obj === 'object') {
                                                                    // Extract value from known keys
                                                                    if (obj.periode) return obj.periode;
                                                                    if (obj.typochronological_unit) return obj.typochronological_unit;
                                                                    if (obj.ecochronological_unit) return obj.ecochronological_unit;
                                                                    if (obj.reference) return obj.reference;
                                                                    return Object.values(obj)[0] || '';
                                                                }
                                                                return String(obj);
                                                            })
                                                            .filter(v => v && v !== 'null' && v.trim() !== '')
                                                            .join(', ');
                                                        value = cleaned || '—';
                                                    } else if (typeof parsed === 'object' && parsed !== null) {
                                                        value = parsed.reference || JSON.stringify(parsed);
                                                    }
                                                } catch (e) {
                                                    // Keep original string if parsing fails
                                                }
                                            }
                                            const label = fieldLabels[key] || key.replace(/_/g, ' ').replace(/\b\w/g, char => char.toUpperCase());
                                            summaryHtml += `<p><strong>${label}:</strong> ${value}</p>`;
                                        }
                                    });
                                    processedSummary = true;
                                }
                            });

                            document.getElementById('summary').innerHTML = summaryHtml;

                            // Create the chart
                            const ctx = document.getElementById('date-chart').getContext('2d');
                            const dates = siteData.map(item => item.bp);
                            const bins = {};
                            dates.forEach(date => {
                                const bin = Math.floor(date / 500) * 500;
                                bins[bin] = (bins[bin] || 0) + 1;
                            });

                            new Chart(ctx, {
                                type: 'bar',
                                data: {
                                    labels: Object.keys(bins).map(bin => `${bin}-${parseInt(bin) + 500} BP`),
                                    datasets: [{
                                        label: '# of Dates',
                                        data: Object.values(bins),
                                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                                        borderColor: 'rgba(75, 192, 192, 1)',
                                        borderWidth: 1
                                    }]
                                },
                                options: {
                                    scales: {
                                        y: {
                                            beginAtZero: true
                                        }
                                    }
                                }
                            });
                        }
                    });
            }
        });
    </script>
</body>
</html>
